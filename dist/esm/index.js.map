{
  "version": 3,
  "sources": ["../../src/components/MarkdownEditor/MarkdownEditor.tsx", "../../src/components/MarkdownEditor/Elements/CodeElement.tsx", "../../src/components/MarkdownEditor/Elements/ParagraphElement.tsx", "../../src/components/MarkdownEditor/Elements/BlockquoteElement.tsx", "../../src/components/MarkdownEditor/Elements/Heading1Element.tsx", "../../src/components/MarkdownEditor/Elements/Heading2Element.tsx", "../../src/components/MarkdownEditor/Elements/Heading3Element.tsx", "../../src/components/MarkdownEditor/Elements/Heading4Element.tsx", "../../src/components/MarkdownEditor/Elements/Heading5Element.tsx", "../../src/components/MarkdownEditor/Elements/Heading6Element.tsx", "../../src/components/MarkdownEditor/Elements/OrderedListElement.tsx", "../../src/components/MarkdownEditor/Elements/UnorderedListElement.tsx", "../../src/components/MarkdownEditor/Elements/UnorderedListItemElement.tsx", "../../src/components/MarkdownEditor/Utils/SlateUtils.ts", "../../src/components/MarkdownEditor/Leafs/CustomLeaf.tsx", "../../src/components/MarkdownEditor/Helpers/CustomLeafHelper.ts", "../../src/components/MarkdownEditor/Toolbar/Toolbar.tsx", "../../src/components/MarkdownEditor/Toolbar/Toolbar.module.css", "../../src/components/MarkdownEditor/ToolbarButton/ToolbarButton.tsx", "../../src/components/MarkdownEditor/ToolbarButton/ToolbarButton.module.css", "../../src/shared/contexts/CustomStyle/Context.tsx", "../../src/components/MarkdownEditor/Utils/HelperUtils.ts", "../../src/components/MarkdownEditor/Helpers/UnorderedListHelper.ts", "../../src/components/MarkdownEditor/Helpers/OrderedListHelper.ts", "../../src/components/MarkdownEditor/Helpers/BlockquoteHelper.ts", "../../src/components/MarkdownEditor/Helpers/CodeHelper.ts", "../../src/components/MarkdownEditor/Helpers/Heading1Helper.ts", "../../src/components/MarkdownEditor/Helpers/Heading2Helper.ts", "../../src/components/MarkdownEditor/Helpers/Heading3Helper.ts", "../../src/components/MarkdownEditor/Helpers/Heading4Helper.ts", "../../src/components/MarkdownEditor/Helpers/Heading5Helper.ts", "../../src/components/MarkdownEditor/Helpers/Heading6Helper.ts", "../../src/components/MarkdownEditor/Helpers/UnorderedListItemHelper.ts", "../../src/components/MarkdownEditor/Helpers/ParagraphHelper.ts", "../../src/components/MarkdownEditor/Helpers/HyperlinkHelper.ts", "../../src/components/MarkdownEditor/Helpers/ImageHelper.ts", "../../src/components/MarkdownEditor/Helpers/OrderedListItemHelper.ts", "../../src/components/MarkdownEditor/Helpers/Helpers.ts", "../../src/components/MarkdownEditor/ToolbarButtonSpacer/ToolbarButtonSpacer.tsx", "../../src/components/MarkdownEditor/ToolbarButtonSpacer/ToolbarButtonSpacer.module.css", "../../src/components/MarkdownEditor/HyperlinkToolbarButton/HyperlinkToolbarButton.tsx", "../../src/shared/components/Popover/Popover.tsx", "../../src/shared/components/Popover/Popover.module.css", "../../src/components/MarkdownEditor/HyperlinkToolbarButton/HyperlinkToolbarButton.module.css", "../../src/shared/components/Form/Form.tsx", "../../src/shared/components/Form/Form.module.css", "../../src/shared/components/FormGroup/FormGroup.tsx", "../../src/shared/components/FormGroup/FormGroup.module.css", "../../src/shared/components/FormLabel/FormLabel.tsx", "../../src/shared/components/FormLabel/FormLabel.module.css", "../../src/shared/components/FormInput/FormInput.tsx", "../../src/shared/components/FormInput/FormInput.module.css", "../../src/shared/components/FormError/FormError.tsx", "../../src/shared/components/FormError/FormError.module.css", "../../src/shared/components/FormButtonGroup/FormButtonGroup.tsx", "../../src/shared/components/FormButtonGroup/FormButtonGroup.module.css", "../../src/shared/components/FormButton/FormButton.tsx", "../../src/shared/components/FormButton/FormButton.module.css", "../../src/components/MarkdownEditor/ImageToolbarButton/ImageToolbarButton.tsx", "../../src/components/MarkdownEditor/ImageToolbarButton/ImageToolbarButton.module.css", "../../src/components/MarkdownEditor/MarkdownEditor.module.css", "../../src/shared/styles/elements.module.css", "../../src/components/MarkdownEditor/UploadModal/UploadModal.tsx", "../../src/components/MarkdownEditor/UploadModal/UploadModal.module.css", "../../src/shared/components/Modal/Modal.tsx", "../../src/shared/components/Modal/Modal.module.css", "../../src/components/MarkdownEditor/Elements/ImageElement.tsx", "../../src/components/MarkdownEditor/Elements/HyperlinkElement.tsx", "../../src/shared/contexts/CustomStyle/Provider.tsx", "../../src/components/MarkdownEditor/Elements/OrderedListItemElement.tsx", "../../src/components/MarkdownView/MarkdownView.tsx", "../../src/shared/serializers/EditorValueMarkdownSerializer.ts", "../../src/components/MarkdownEditor/Upload/Uploader/AbstractUploader.ts"],
  "sourcesContent": ["import React, { useCallback, useState, KeyboardEvent, FocusEvent, useRef, useMemo } from 'react';\nimport { createEditor, Descendant } from 'slate';\nimport { Slate, Editable, withReact, RenderElementProps, ReactEditor } from 'slate-react';\nimport { CodeElement } from './Elements/CodeElement';\nimport { ParagraphElement } from './Elements/ParagraphElement';\nimport { CustomElement } from './Types/CustomElement';\nimport { CustomText } from './Types/CustomText';\nimport { CustomEditor } from './Types/CustomEditor';\nimport { BlockquoteElement } from './Elements/BlockquoteElement';\nimport { Heading1Element } from './Elements/Heading1Element';\nimport { Heading2Element } from './Elements/Heading2Element';\nimport { Heading3Element } from './Elements/Heading3Element';\nimport { Heading4Element } from './Elements/Heading4Element';\nimport { Heading5Element } from './Elements/Heading5Element';\nimport { Heading6Element } from './Elements/Heading6Element';\nimport { OrderedListElement } from './Elements/OrderedListElement';\nimport { UnorderedListElement } from './Elements/UnorderedListElement';\nimport { UnorderedListItemElement } from './Elements/UnorderedListItemElement';\nimport { SlateUtils } from './Utils/SlateUtils';\nimport { CustomLeafProps, CustomLeaf } from './Leafs/CustomLeaf';\nimport { CustomLeafHelper } from './Helpers/CustomLeafHelper';\nimport { Toolbar } from './Toolbar/Toolbar';\nimport { BlockHelpersArray, Helpers, InlineHelpersArray, VoidHelpersArray } from './Helpers/Helpers';\nimport styles from './MarkdownEditor.module.css';\nimport elementStyles from '../../shared/styles/elements.module.css';\nimport { UploadModal } from './UploadModal/UploadModal';\nimport { AbstractUploader, UploaderFinishCallback } from './Upload/Uploader/AbstractUploader';\nimport { ImageElement } from './Elements/ImageElement';\nimport { HyperlinkElement } from './Elements/HyperlinkElement';\nimport { HyperlinkHelper } from './Helpers/HyperlinkHelper';\nimport { ImageHelper } from './Helpers/ImageHelper';\nimport { CustomStyleContextProvider } from '../../shared/contexts/CustomStyle/Provider';\nimport { CustomStyle } from '../../shared/contexts/CustomStyle/Context';\nimport { OrderedListItemElement } from './Elements/OrderedListItemElement';\n\n/**\n * Extend the CustomTypes in the slate module to tell slate what custom elements we have.\n */\ndeclare module 'slate' {\n    interface CustomTypes {\n        Editor: CustomEditor;\n        Element: CustomElement;\n        Text: CustomText;\n    }\n}\n\n/**\n * Describes the type of the value the editor holds.\n */\nexport type EditorValue = CustomElement[];\n\n/**\n * Props for the MarkdownEditor component.\n */\nexport interface MarkdownEditorProps {\n    // Called after each editor change.\n    // Passes the current ast of elements, that can be saved anywhere. Note that this is called everytime the user\n    // changes something in the editor. If you do not want to track every change, you can use onBlur instead.\n    onChange?: (value: EditorValue) => void;\n\n    // Called after the focus of the editor was lost.\n    // Passes the current ast, hence it can be saved anywhere.\n    onBlur?: (event: FocusEvent<HTMLDivElement>, value: EditorValue) => void;\n\n    // The initial value the editor should have. If this is passed, it will be prioritized instead of defaultText.\n    initialValue?: EditorValue;\n\n    // The optional initial text the value of the editor should be if no initial value was passed or was empty.\n    defaultText?: string;\n\n    // Holds css classes and values to customize the style of the editor\n    customStyle?: CustomStyle;\n\n    // If given, file uploads are enabled\n    uploadInfo?: {\n        // Uploader that is used for uploading files, see AbstractUploader to build your own uploader\n        uploader: AbstractUploader;\n\n        // If given, the selected file types will be validated before upload. Can be a comma seperated string of\n        // valid mime types, including *, eg. \"image/*, application/csv\"\n        acceptedFileTypes?: string;\n\n        // If given, the selected file sizes (in bytes) will be validated before upload\n        maxFileSize?: number;\n    };\n}\n\n/**\n * A react markown wysiwyg editor.\n * The current markdown is given via the props. If the value was submitted by the useer, hence the editing\n * was finished, the onSubmit callback in the props will be called.\n *\n * @param props\n * @constructor\n */\nexport const MarkdownEditor = (props: MarkdownEditorProps) => {\n    const [editor] = useState(() => withVoids(withInlines(withReact(createEditor()))));\n    const [uploadModalData, setUploadModalData] = useState<{\n        show: boolean;\n        accept?: string;\n        forceAttachment?: boolean;\n    }>({ show: false });\n\n    // Use ref instead state here to prevent rerender\n    const currentAst = useRef<CustomElement[]>([]);\n\n    /**\n     * Defines all custom renderers for elements, based on its element type given by the props.\n     */\n    const renderElement = useCallback((props: RenderElementProps) => {\n        switch (props.element.type) {\n            case 'blockquote':\n                return <BlockquoteElement {...props} />;\n            case 'code':\n                return <CodeElement {...props} />;\n            case 'heading-1':\n                return <Heading1Element {...props} />;\n            case 'heading-2':\n                return <Heading2Element {...props} />;\n            case 'heading-3':\n                return <Heading3Element {...props} />;\n            case 'heading-4':\n                return <Heading4Element {...props} />;\n            case 'heading-5':\n                return <Heading5Element {...props} />;\n            case 'heading-6':\n                return <Heading6Element {...props} />;\n            case 'image':\n                return <ImageElement {...props} />;\n            case 'hyperlink':\n                return <HyperlinkElement {...props} />;\n            case 'ordered-list-item':\n                return <OrderedListItemElement {...props} />;\n            case 'ordered-list':\n                return <OrderedListElement {...props} />;\n            case 'unordered-list':\n                return <UnorderedListElement {...props} />;\n            case 'unordered-list-item':\n                return <UnorderedListItemElement {...props} />;\n            default:\n                return <ParagraphElement {...props} />;\n        }\n    }, []);\n\n    /**\n     * Defines a custom renderer for leafes slate creates.\n     * Leaves are part of text that can contain custom styles.\n     * Usually this is not needed in case of markdown, but it is added for completition here.\n     */\n    const renderLeaf = useCallback((props: CustomLeafProps) => {\n        return <CustomLeaf {...props} />;\n    }, []);\n\n    /**\n     * Called if the user typed something into the editor.\n     * Catches the inputs to transform them to the corresponding custom rendered elements.\n     *\n     * @param event\n     */\n    const onKeyDown = (event: KeyboardEvent<HTMLDivElement>) => {\n        switch (event.key) {\n            // Format based components, handled as leafes\n            case '_':\n            case '*': {\n                CustomLeafHelper.handleBoldAndItalic(editor, event);\n\n                break;\n            }\n\n            // Shortcut based components for space, Dead key is a special case for `,\n            // because javascript can not handle this key, because HUEHUEHUEHUEHUEHUEHUEHUEHUEHUE\n            case ' ':\n            case 'Dead': {\n                // We want to see if the text since block start is a markdown shortcut\n                const shortcutText = SlateUtils.textSinceBlockStart(editor);\n                if (!shortcutText) break;\n\n                // Find block matching shortcuts\n                let blockRendered = false;\n                for (const helper of BlockHelpersArray) {\n                    // matching shortcut with text or regex possible\n                    if (shortcutText === helper.shortcutText || helper.shortcutRegex?.test(shortcutText)) {\n                        // remove the shortcut text\n                        SlateUtils.deleteFromLeft(editor, shortcutText.length);\n\n                        // Render the corresponding markdown element\n                        helper.toggle(editor, { actor: 'shortcut', actorShortcut: shortcutText });\n\n                        // Prevent the newest key from being printed\n                        event.preventDefault();\n\n                        // used to skip execution of inline element rendering\n                        blockRendered = true;\n\n                        break;\n                    }\n                }\n\n                if (blockRendered || !editor.selection) return;\n\n                // Find inline matching shortcuts\n                for (const helper of InlineHelpersArray) {\n                    if (!helper.shortcutRegex) continue;\n\n                    const match = shortcutText.match(helper.shortcutRegex);\n                    if (!match) continue;\n\n                    // Delete shortcut text\n                    SlateUtils.deleteAt(\n                        editor,\n                        { path: editor.selection.anchor.path, offset: shortcutText.length - match[0].length },\n                        match[0].length\n                    );\n\n                    // toggle inline node\n                    helper.toggle(editor, { actor: 'shortcut', actorShortcutMatch: match });\n\n                    // Prevent the newest key from being printed\n                    event.preventDefault();\n\n                    break;\n                }\n\n                break;\n            }\n\n            // Some components like list actions react on a tab press.\n            case 'Tab': {\n                const currentBlockType = SlateUtils.currentBlockType(editor);\n                if (!currentBlockType) break;\n\n                const onTabFunc = Helpers[currentBlockType].onTab;\n                if (!onTabFunc) break;\n\n                onTabFunc(editor, event);\n\n                // prevent default is not called here, because the onTab handlers should be able to\n                // decide whether the slate default action will be processed\n                break;\n            }\n\n            // Normally pressing enter should create a new paragraph, but for some cases this should not be the case.\n            // If some onEnter callback for the current block type exists, this will be handled instead of the default case\n            case 'Enter': {\n                const currentElementType = SlateUtils.currentElementType(editor);\n                if (!currentElementType) break;\n\n                // onEnter exists on current type => call onEnter\n                const onEnterFunc = Helpers[currentElementType].onEnter;\n                if (!onEnterFunc) break;\n\n                onEnterFunc(editor, event);\n\n                // prevent default is not called here, because the onEnter handlers should be able to\n                // decide whether the slate default action will be processed\n                break;\n            }\n        }\n    };\n\n    /**\n     * Called if the value of the slate component changes.\n     * Generates the markdown and submits it via the callback given by the props, if the content\n     * was changed and submitted.\n     *\n     * @param value\n     */\n    const onSlateChange = (value: Descendant[]) => {\n        const isAstChange = editor.operations.some((op) => 'set_selection' !== op.type);\n\n        if (isAstChange) {\n            currentAst.current = value as EditorValue;\n\n            if (!props.onChange) return;\n\n            props.onChange(value as EditorValue);\n        }\n    };\n\n    /**\n     * Called if the editor looses focus. Calls the onBlur callback, if given by the props.\n     * Passes the current Ast value to that callback.\n     */\n    const onBlur = (event: FocusEvent<HTMLDivElement>) => {\n        if (!props.onBlur) return;\n\n        props.onBlur(event, currentAst.current);\n\n        event.preventDefault();\n    };\n\n    /**\n     * Called if the user requests some file upload.\n     * Opens the dialog to upload the file.\n     * The accept parameter is a comma separated string of accepted mime types.\n     * If not given, everything will be accepted.\n     * If forceAttachment is set to true, the uploaded file will be shown as link instead of rendered content.\n     *\n     * @param accept\n     * @param forceAttachment\n     */\n    const onUploadRequest = (accept?: string, forceAttachment?: boolean) => {\n        setUploadModalData({ show: true, accept: accept, forceAttachment: forceAttachment });\n    };\n\n    /**\n     * Called if the upload modal should be closed.\n     * Closes the upload modal and sets the focus to the editor again.\n     */\n    const onCloseUploadModal = () => {\n        setUploadModalData({ show: false });\n\n        ReactEditor.focus(editor);\n    };\n\n    /**\n     * Called if some file upload was finished.\n     * Creates an image or link tag, depending on the uploaded file type.\n     * The originalFile is the file the user selected to upload.\n     *\n     * @param fileUrl\n     * @param originalFile\n     * @param metaData\n     */\n    const onUploadFinished: UploaderFinishCallback = (\n        fileUrl: string,\n        originalFile: File,\n        metaData: Record<string, string>\n    ) => {\n        if (originalFile.type.includes('image') && !uploadModalData.forceAttachment) {\n            if (!ImageHelper.onUpsert) return;\n\n            ImageHelper.onUpsert(editor, { src: fileUrl, metaData: metaData });\n        } else {\n            if (!HyperlinkHelper.onUpsert) return;\n\n            HyperlinkHelper.onUpsert(editor, {\n                children: [{ text: originalFile.name }],\n                href: fileUrl,\n                metaData: metaData\n            });\n        }\n\n        onCloseUploadModal();\n    };\n\n    /**\n     * Called if the initialValue or defaultText in the props changes.\n     * Returns the initial value for the slate editor.\n     */\n    const initialValue: CustomElement[] = useMemo(() => {\n        if (props.initialValue && props.initialValue.length > 0) {\n            return props.initialValue;\n        }\n\n        return [\n            {\n                type: 'paragraph',\n                children: [{ text: props.defaultText !== undefined ? props.defaultText : '' }]\n            }\n        ];\n    }, [props.initialValue, props.defaultText]);\n\n    return (\n        <CustomStyleContextProvider value={props.customStyle}>\n            <Slate editor={editor}  initialValue={initialValue} onChange={onSlateChange}>\n                <div className={`${styles.container} ${props.customStyle?.editor?.containerClassName || ''}`}>\n                    <Toolbar onUploadRequest={props.uploadInfo ? onUploadRequest : undefined} />\n\n                    <Editable\n                        className={`${styles.editor} ${elementStyles.container} ${\n                            props.customStyle?.editor?.editorContainerClassName || ''\n                        }`}\n                        renderElement={renderElement}\n                        renderLeaf={renderLeaf}\n                        onKeyDown={onKeyDown}\n                        onBlur={onBlur}\n                    />\n                </div>\n\n                {props.uploadInfo && uploadModalData.show && (\n                    <UploadModal\n                        onUploadFinish={onUploadFinished}\n                        onClose={onCloseUploadModal}\n                        {...props.uploadInfo}\n                        acceptedFileTypes={uploadModalData.accept || props.uploadInfo.acceptedFileTypes}\n                    />\n                )}\n            </Slate>\n        </CustomStyleContextProvider>\n    );\n};\n\n/**\n * Overwrites the isInline method of the slate editor to specify the elemnts that should be rendered inline.\n *\n * @param editor\n */\nconst withInlines = (editor: CustomEditor): CustomEditor => {\n    const { isInline } = editor;\n\n    editor.isInline = (element: CustomElement): boolean => {\n        const inlineTypes = InlineHelpersArray.map((helper) => helper.elementType);\n\n        return inlineTypes.includes(element.type) || isInline(element);\n    };\n\n    return editor;\n};\n\n/**\n * Overwrites the isVoid method of the slate editor to specify the elemnts that should not render its children by slate.\n *\n * @param editor\n */\nconst withVoids = (editor: CustomEditor): CustomEditor => {\n    const { isVoid } = editor;\n\n    editor.isVoid = (element: CustomElement): boolean => {\n        const inlineTypes = VoidHelpersArray.map((helper) => helper.elementType);\n\n        return inlineTypes.includes(element.type) || isVoid(element);\n    };\n\n    return editor;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the CodeElement component.\n */\ntype CodeElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a code block.\n *\n * @param props\n * @constructor\n */\nexport const CodeElement = (props: CodeElementProps) => {\n    return (\n        <pre {...props.attributes}>\n            <code>{props.children}</code>\n        </pre>\n    );\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the ParagraphElement component.\n */\ntype ParagraphElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a paragraph element.\n *\n * @param props\n * @constructor\n */\nexport const ParagraphElement = (props: ParagraphElementProps) => {\n    return <p {...props.attributes}>{props.children}</p>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the CodeElement component.\n */\ntype BlockquoteElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a cite block.\n *\n * @param props\n * @constructor\n */\nexport const BlockquoteElement = (props: BlockquoteElementProps) => {\n    return <blockquote {...props.attributes}>{props.children}</blockquote>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the Heading1Element component.\n */\ntype Heading1ElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a heading of size 1.\n *\n * @param props\n * @constructor\n */\nexport const Heading1Element = (props: Heading1ElementProps) => {\n    return <h1 {...props.attributes}>{props.children}</h1>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the Heading1Element component.\n */\ntype Heading2ElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a heading of size 2.\n *\n * @param props\n * @constructor\n */\nexport const Heading2Element = (props: Heading2ElementProps) => {\n    return <h2 {...props.attributes}>{props.children}</h2>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the Heading1Element component.\n */\ntype Heading3ElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a heading of size 3.\n *\n * @param props\n * @constructor\n */\nexport const Heading3Element = (props: Heading3ElementProps) => {\n    return <h3 {...props.attributes}>{props.children}</h3>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the Heading1Element component.\n */\ntype Heading4ElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a heading of size 4.\n *\n * @param props\n * @constructor\n */\nexport const Heading4Element = (props: Heading4ElementProps) => {\n    return <h4 {...props.attributes}>{props.children}</h4>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the Heading1Element component.\n */\ntype Heading5ElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a heading of size 5.\n *\n * @param props\n * @constructor\n */\nexport const Heading5Element = (props: Heading5ElementProps) => {\n    return <h5 {...props.attributes}>{props.children}</h5>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the Heading1Element component.\n */\ntype Heading6ElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a heading of size 6.\n *\n * @param props\n * @constructor\n */\nexport const Heading6Element = (props: Heading6ElementProps) => {\n    return <h6 {...props.attributes}>{props.children}</h6>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the OrderedListElement component.\n */\ntype OrderedListElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering an ordered list.\n *\n * @param props\n * @constructor\n */\nexport const OrderedListElement = (props: OrderedListElementProps) => {\n    return <ol {...props.attributes}>{props.children}</ol>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the UnorderedListElement component.\n */\ntype UnorderedListElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering an unordered list.\n *\n * @param props\n * @constructor\n */\nexport const UnorderedListElement = (props: UnorderedListElementProps) => {\n    return <ul {...props.attributes}>{props.children}</ul>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the UnorderedListElement component.\n */\ntype UnorderedListItemElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a list item in an unordered or ordered list.\n *\n * @param props\n * @constructor\n */\nexport const UnorderedListItemElement = (props: UnorderedListItemElementProps) => {\n    return <li {...props.attributes}>{props.children}</li>;\n};\n", "import { CustomEditor } from '../Types/CustomEditor';\nimport { Editor, Node, Point, Transforms, Element, Text, Descendant } from 'slate';\nimport { CustomElement, CustomElementType } from '../Types/CustomElement';\nimport { CustomText } from '../Types/CustomText';\n\n/**\n * Changes the type of the current node to the specified elementType.\n * The content will not be changed.\n * If props are given, they are merged to the node props.\n *\n * @param editor\n * @param elementType\n * @param props\n */\nconst changeCurrentNodeType = (\n    editor: CustomEditor,\n    elementType: CustomElementType,\n    props?: Partial<CustomElement>\n) => {\n    Transforms.setNodes(editor, { ...props, type: elementType });\n};\n\n/**\n * Removes the inline node on the current cursor location, by lifting up its children.\n *\n * @param editor\n */\nconst removeInlineNode = (editor: CustomEditor) => {\n    const path = currentElementPath(editor);\n    if (!path) return;\n\n    Transforms.unwrapNodes(editor, { at: path });\n};\n\n/**\n * Returns the path to the nearest non leaf element, meaning the next element not being a leaf.\n * If the path could not be found, null will be returned.\n *\n * @param editor\n */\nconst currentElementPath = (editor: CustomEditor): number[] | null => {\n    if (!editor.selection) return null;\n\n    // This is based on the assumption that the users cursor is always in some leaf node\n    return editor.selection.anchor.path.slice(0, -1);\n};\n\n/**\n * Returns the element at the current cursors position.\n * This is the first element not being a leaf. This also includes inline elements like images and hyperlinks.\n *\n * @param editor\n */\nconst currentElement = (editor: CustomEditor): CustomElement | null => {\n    let currentPath = editor.selection?.anchor.path;\n    if (!currentPath) return null;\n\n    // this is an assumption, because the selected node should be the leaf, hence we need the leafs parent\n    currentPath = currentPath.slice(0, -1);\n    const element = Node.get(editor, currentPath) as CustomElement;\n\n    return element;\n};\n\n/**\n * Returns the type name of the element node the user is currently located in.\n * If the type could not be found, null will be returned.\n * Note that this returns the type of the element, including inline elements. If you need\n * the type of the block, use currentBlockType instead.\n *\n * @param editor\n */\nconst currentElementType = (editor: CustomEditor): CustomElementType | null => {\n    if (!editor.selection) return null;\n\n    const element = currentElement(editor);\n    if (!element) {\n        return null;\n    }\n\n    return element.type;\n};\n\n/**\n * Returns the nearest element having the specified type in the parents and the node itself at the current users selection.\n * If no element was found, null will be returned.\n *\n * @param editor\n * @param elementType\n */\nconst nearestElementOfType = (editor: CustomEditor, elementType: CustomElementType): CustomElement | null => {\n    let currentPath = editor.selection?.anchor.path;\n    if (!currentPath) return null;\n\n    do {\n        const currentElement = Node.get(editor, currentPath) as CustomElement;\n        if (!currentElement) return null;\n\n        if (currentElement.type === elementType) return currentElement;\n\n        currentPath = currentPath?.slice(0, -1);\n    } while (currentPath.length > 0);\n\n    return null;\n};\n\n/**\n * Creates a new node of the same type at the current cursors position.\n *\n * @param editor\n */\nconst createNewNodeOfCurrentType = (editor: CustomEditor) => {\n    // Splitting should force the editor to create a new node\n    Transforms.splitNodes(editor, { always: true });\n};\n\n/**\n * Creates a new node having the specified type at the current cursors position.\n *\n * The options hold the following values:\n * The node children will be assigned, if given. If this is not set, a leaf with empty text will be created as children.\n * Note that this is necessary for slate because if the node does not have any leaf as children, any selection on\n * the node will fail.\n * The props are passed to the node. This can eg. be the src attribute for the image, or the href attribute\n * for the hyperlink.\n * If voids is set to true, not slate renders its children, but the element does. This is useful for nodes\n * having no children, like images.\n * If createFollowingParagraph is set to true, a paragraph after the inserted node will be created. This makes the cursor of the editor\n * to move not into the created node, but to the paragraph after the created node. Note that the paragraph is not a voide node,\n * even if you defined it for the inserted one.\n * If createFollowingText is set to true, a following leaf having the text will be created beside the created node.\n *\n * @param editor\n * @param type\n * @param options\n */\nconst createNewNode = (\n    editor: CustomEditor,\n    type: CustomElementType,\n    options: {\n        children?: Descendant[];\n        props?: Partial<CustomElement>;\n        voids?: boolean;\n        createFollowingParagraph?: boolean;\n        createFollowingText?: string;\n    } = {}\n) => {\n    Transforms.insertNodes(\n        editor,\n        {\n            ...options.props,\n            type: type,\n            children: options.children || [{ text: '' }]\n        },\n        { voids: options.voids }\n    );\n\n    if (options.createFollowingParagraph) {\n        Transforms.insertNodes(editor, { type: 'paragraph', children: [{ text: '' }] });\n    }\n\n    if (options.createFollowingText !== undefined) {\n        if (!editor.selection) return;\n\n        // target path for inserting the empty leaf\n        const targetPath = Editor.parent(editor, editor.selection)[1];\n        targetPath[targetPath.length - 1]++;\n\n        // insert at target path\n        Transforms.insertNodes(editor, { text: options.createFollowingText }, { at: targetPath });\n\n        // point cursor to the new target\n        Transforms.select(editor, {\n            anchor: {\n                path: targetPath,\n                offset: options.createFollowingText.length\n            },\n            focus: {\n                path: targetPath,\n                offset: options.createFollowingText.length\n            }\n        });\n    }\n};\n\n/**\n * Wraps the node of the current editors position in a new node of the specified elementType.\n * The optional props are added to the wrapping node.\n *\n * @param editor\n * @param elementType\n * @param props\n */\nconst wrapNode = (editor: CustomEditor, elementType: CustomElementType, props: Partial<CustomElement> = {}) => {\n    Transforms.wrapNodes(editor, { type: elementType, ...props }, { split: true });\n};\n\n/**\n * Unwraps the current node (not leaf) at the editors selection, hence the current node is located in the parent.\n *\n * @param editor\n */\nconst unwrapNode = (editor: CustomEditor) => {\n    Transforms.liftNodes(editor);\n};\n\n/**\n * Unwraps the current leaf at the editors selection, hence the current leaf is located in the parent node.\n *\n * @param editor\n */\nconst unwrapLeaf = (editor: CustomEditor) => {\n    Transforms.unwrapNodes(editor);\n};\n\n/**\n * Returns whether the editors selection is a cursor, meaining the user did not select any text,\n * but is located somewhere in the editor.\n *\n * @param editor\n */\nconst isCursor = (editor: CustomEditor): boolean => {\n    if (!editor.selection) {\n        return false;\n    }\n\n    return Point.equals(editor.selection.anchor, editor.selection.focus);\n};\n\n/**\n * Returns whether the user selected some text.\n *\n * @param editor\n */\nconst isSelection = (editor: CustomEditor): boolean => {\n    if (!editor.selection) {\n        return false;\n    }\n\n    return !isCursor(editor);\n};\n\n/**\n * Returns the start location of the current selected block.\n *\n * @param editor\n */\nconst currentBlockStart = (editor: CustomEditor): Point => {\n    // Get the nearest block from the selection\n    const block = Editor.above(editor, {\n        match: (n) => Editor.isBlock(editor, n as CustomElement)\n    });\n\n    // The path to the block is located in the second item of the result\n    const path = block ? block[1] : [];\n\n    // Find the start point of the block\n    return Editor.start(editor, path);\n};\n\n/**\n * Returns the end location of the current seleczed block.\n *\n * @param editor\n */\nconst currentBlockEnd = (editor: CustomEditor): Point => {\n    // Get the nearest block from the selection\n    const block = Editor.above(editor, {\n        match: (n) => Editor.isBlock(editor, n as CustomElement)\n    });\n\n    // The path to the block is located in the second item of the result\n    const path = block ? block[1] : [];\n\n    // Find the end point of the block\n    return Editor.end(editor, path);\n};\n\n/**\n * Returns the text from the start of the block of the current cursor in the specified slate editor.\n * Returns null if the text could not be found.\n *\n * @param editor\n */\nconst textSinceBlockStart = (editor: CustomEditor): string | null => {\n    if (!editor.selection) return null;\n\n    // Find the start point of the block\n    const start = currentBlockStart(editor);\n\n    // Build a range object from the current selection to the start point\n    const range = { anchor: editor.selection.anchor, focus: start };\n\n    // extract the text from the range\n    return Editor.string(editor, range);\n};\n\n/**\n * Returns the text from the current cursor of the slate editor to the block end.\n * Returns null if the text could not be found.\n *\n * @param editor\n */\nconst textToBlockEnd = (editor: CustomEditor): string | null => {\n    if (!editor.selection) return null;\n\n    // Find the end point of the block\n    const end = currentBlockEnd(editor);\n\n    // Build a range object from the current selection to the start point\n    const range = { anchor: editor.selection.focus, focus: end };\n\n    // extract the text from the range\n    return Editor.string(editor, range);\n};\n\n/**\n * Returns the location of the last occurence of the specified text from the editors current selection start\n * in the block of the current selection.\n * This only works if the current selection has the same anchor and focus, meaning the user did not select any text.\n *\n * If the isolated option is passed, the position is only returned if the occurence is not beside the searchText itself.\n * This means for instance, if you search for _ and the text contains __, the position of _ will not be returned.\n * The position will only be returned if the text is surrounded not by the search text.\n * Note that if isolated is passed, it will only check the isolation for the last found occurence. If the text contains some\n * isolated characters before that occurence, they will not be found.\n *\n * @param editor\n * @param searchText\n */\nconst lastPosOf = (editor: CustomEditor, searchText: string, options?: { isolated?: true }): Point | null => {\n    if (!editor.selection) return null;\n\n    // Select the text between start of the block and the current cursor position\n    const blockText = currentBlockText(editor);\n    if (!blockText) {\n        return null;\n    }\n\n    // Find last occurence of search text\n    const lastIndex = blockText.lastIndexOf(searchText);\n\n    // If the isolated option is set to true, the searchText must not beside searchText\n    if (options?.isolated) {\n        if (blockText.substring(lastIndex + searchText.length, lastIndex + searchText.length * 2) === searchText) {\n            return null;\n        }\n\n        if (blockText.substring(lastIndex - searchText.length, lastIndex) === searchText) {\n            return null;\n        }\n    }\n\n    if (lastIndex === -1) {\n        return null;\n    }\n\n    return {\n        path: editor.selection.anchor.path,\n        offset: lastIndex\n    };\n};\n\n/**\n * Returns whether the current cursor is behind the specified searchText, meaninig that the searchText is\n * left beside the cursor.\n * If the user has currently selected text, false will be returned.\n *\n * @param editor\n * @param searchText\n */\nconst cursorIsBehind = (editor: CustomEditor, searchText: string): boolean => {\n    if (!editor.selection || !isCursor(editor)) return false;\n\n    return !!textSinceBlockStart(editor)?.endsWith(searchText);\n};\n\n/**\n * Returns the text of the block the user has currently selected.\n * If the user has not selected anything, null will be returned.\n *\n * @param editor\n */\nconst currentBlockText = (editor: CustomEditor): string | null => {\n    if (!editor.selection) {\n        return null;\n    }\n\n    // Select the text between start of the block and the current cursor position\n    return Editor.string(editor, {\n        anchor: { path: editor.selection.anchor.path, offset: 0 },\n        focus: editor.selection.anchor\n    });\n};\n\n/**\n * Sets the text of the block the user has currently selected.\n *\n * @param editor\n * @param text\n */\nconst setCurrentBlockText = (editor: CustomEditor, text: string): void => {\n    if (!editor.selection) {\n        return;\n    }\n\n    const start = currentBlockStart(editor);\n    if (!start) return;\n\n    Transforms.delete(editor, {\n        at: {\n            anchor: start,\n            focus: editor.selection.anchor\n        }\n    });\n\n    Transforms.insertText(editor, text, {\n        at: start\n    });\n};\n\n/**\n * Removes the number of chars from the beginning of the block that is currently selected by the user.\n *\n * @param editor\n * @param numChars\n */\nconst deleteFromLeft = (editor: CustomEditor, numChars: number): void => {\n    let text = currentBlockText(editor);\n    if (!text) {\n        return;\n    }\n\n    text = text.slice(numChars);\n\n    setCurrentBlockText(editor, text);\n};\n\n/**\n * Removes the number of chars from the current cursor in the editor (backwards).\n *\n * @param editor\n * @param numChars\n */\nconst deleteFromRight = (editor: CustomEditor, numChars: number): void => {\n    for (let i = 0; i < numChars; i++) {\n        Editor.deleteBackward(editor, { unit: 'character' });\n    }\n};\n\n/**\n * Removes numChars characters from the text starting at the specified start point.\n *\n * @param editor\n * @param start\n * @param numChars\n */\nconst deleteAt = (editor: CustomEditor, start: Point, numChars: number) => {\n    Transforms.delete(editor, {\n        at: start,\n        distance: numChars,\n        unit: 'character'\n    });\n};\n\n/**\n * Checks whether the cursor is in a node being a child of a node having any of the specified elementTypes.\n * This checks recursively in the tree, not only one parent.\n *\n * @param editor\n * @param elementTypes\n */\nconst isChildOfAny = (editor: CustomEditor, elementTypes: CustomElementType[]): boolean => {\n    if (!editor.selection) return false;\n\n    return (\n        Editor.above(editor, {\n            match: (n) => elementTypes.includes((n as Element).type)\n        }) !== undefined\n    );\n};\n\n/**\n * Checks whether the cursor is in a node being a child of a node having the specified type elementType.\n * This checks recursively in the tree, not only one parent.\n *\n * @param editor\n * @param elementType\n */\nconst isChildOf = (editor: CustomEditor, elementType: CustomElementType): boolean => {\n    if (!editor.selection) return false;\n\n    return isChildOfAny(editor, [elementType]);\n};\n\n/**\n * Returns the current block element of the cursor the user is currently located.\n * If the element could not be found, null will be returned.\n * Note that this method does not return leafs or inline elements.\n * It only returns the nearest block element the user is located in.\n *\n * @param editor\n */\nconst currentBlock = (editor: CustomEditor): CustomElement | null => {\n    if (!editor.selection) return null;\n\n    const nodeEntry = Editor.above(editor, { match: (n) => Editor.isBlock(editor, n as CustomElement) });\n    if (!nodeEntry) {\n        return null;\n    }\n\n    if (!isElement(nodeEntry[0])) {\n        return null;\n    }\n\n    return nodeEntry[0] as CustomElement;\n};\n\n/**\n * Returns the path to the nearest block element.\n * If the path could not be found, null will be returned.\n *\n * @param editor\n */\nconst currentBlockPath = (editor: CustomEditor): number[] | null => {\n    if (!editor.selection) return null;\n\n    const currentPath = currentElementPath(editor);\n    if (!currentPath) return null;\n\n    return nearestBlockPath(editor, currentPath);\n};\n\n/**\n * Returns the nearest path above the specified path that contains a block.\n * If the path could not be found, null will be returned.\n *\n * @param editor\n * @param path\n */\nconst nearestBlockPath = (editor: CustomEditor, path: number[]): number[] | null => {\n    let currentPath = path;\n    if (currentPath.length === 0) return null;\n\n    do {\n        const currentElement = Node.get(editor, currentPath);\n        if (!currentElement) return null;\n\n        if (Editor.isBlock(editor, currentElement as CustomElement)) {\n            return currentPath;\n        }\n\n        currentPath = currentPath.slice(0, -1);\n    } while (currentPath.length > 0);\n\n    return null;\n};\n\n/**\n * Returns the type name of the block node the user is currently located in.\n * If the type could not be found, null will be returned.\n * Note that this returns the type of the block, not of inline elements.\n *\n * @param editor\n */\nconst currentBlockType = (editor: CustomEditor): CustomElementType | null => {\n    if (!editor.selection) return null;\n\n    const element = currentBlock(editor);\n    if (!element) {\n        return null;\n    }\n\n    return element.type;\n};\n\n/**\n * Returns the parent block element of the current cursors position in the editor.\n * If the parent could not be specified, null will be returned.\n * Note that this method does not return leaves. It only returns the nearest parent of\n * the element the user is located in.\n *\n * @param editor\n */\nconst parentBlock = (editor: CustomEditor): CustomElement | null => {\n    if (!editor.selection) return null;\n\n    let currentPath = currentBlockPath(editor);\n    if (!currentPath) return null;\n\n    currentPath = currentPath.slice(0, -1);\n    currentPath = nearestBlockPath(editor, currentPath);\n\n    if (!currentPath) return null;\n\n    return Node.get(editor, currentPath) as CustomElement;\n};\n\n/**\n * Returns the type of the parent of the current cursors position in the editor.\n * If the parent could not be specified, null will be returned.\n *\n * @param editor\n */\nconst parentBlockType = (editor: CustomEditor): CustomElementType | null => {\n    const element = parentBlock(editor);\n    if (!element) return null;\n\n    return element.type;\n};\n\n/**\n * Returns the leaf at the current editors cursor.\n * If the leaf could not be found, null will be returned.\n *\n * @param editor\n */\nconst currentLeaf = (editor: CustomEditor): CustomText | null => {\n    if (!editor.selection) return null;\n\n    const nodeEntry = Editor.node(editor, editor.selection.anchor);\n    if (!nodeEntry || !isLeaf(nodeEntry[0])) {\n        return null;\n    }\n\n    return nodeEntry[0] as CustomText;\n};\n\n/**\n * Returns whether the specified node is an element.\n *\n * @param node\n */\nconst isElement = (node: Node): boolean => {\n    // assuming that if a type is available, it is an element\n    const element = node as CustomElement;\n    if (element && element['type']) {\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Returns whether the specified node is a leaf node having only text.\n *\n * @param node\n */\nconst isLeaf = (node: Node): boolean => {\n    // assuming that if a text is available, it is an leaf\n    const leaf = node as CustomText;\n    if (leaf && leaf['text']) {\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Returns whether the current selection in the editor is at the root node,\n * meaning not being wrapped in any element.\n *\n * @param editor\n */\nconst isAtRoot = (editor: CustomEditor): boolean => {\n    const pos = editor.selection?.anchor || editor.selection?.focus;\n    if (!pos) return false;\n\n    return pos.path.length <= 2;\n};\n\n/**\n * Returns whether the current node is the root node.\n *\n * @param node\n */\nconst isRoot = (node: Node): boolean => {\n    const leaf = node as CustomText;\n    const element = node as CustomElement;\n\n    // assuming that if no text and type is available, it is the root node\n    if (!leaf['text'] && !element['type']) {\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Returns whether the current text node the users cursors is located in is empty or not.\n *\n * @param editor\n */\nconst isEmpty = (editor: CustomEditor): boolean => {\n    if (isSelection(editor) || !editor.selection) {\n        return false;\n    }\n\n    const leaf = currentLeaf(editor);\n    if (!leaf) {\n        return true;\n    }\n\n    return leaf.text === '';\n};\n\n/**\n * Creates a new paragraph at root level in the current cursors block.\n * If the block contains text from the cursor to the block end, this text will be added to the new\n * paragraph.\n *\n * @param editor\n */\nconst createRootParagraph = (editor: CustomEditor): void => {\n    if (!editor.selection) {\n        return;\n    }\n\n    createNewNodeOfCurrentType(editor);\n\n    // set the type to paragraph\n    changeCurrentNodeType(editor, 'paragraph');\n\n    liftToRoot(editor);\n};\n\n/**\n * Creates a newline at the cursor position of the editor.\n *\n * @param editor\n */\nconst createNewline = (editor: CustomEditor): void => {\n    Transforms.insertText(editor, '\\n');\n};\n\n/**\n * Moves the node at the current editors selection to root level.\n *\n * @param editor\n */\nconst liftToRoot = (editor: CustomEditor): void => {\n    while (!SlateUtils.isAtRoot(editor)) {\n        Transforms.liftNodes(editor);\n    }\n};\n\n/**\n * Sets the formatting of the leaf node at the specified range.\n * If range is not defined, the current editors selection will be used for the operation.\n *\n * @param editor\n * @param formatOptions\n * @param range\n */\nconst setLeafFormat = (\n    editor: CustomEditor,\n    formatOptions: { bold?: boolean; italic?: boolean },\n    range?: { anchor: Point; focus: Point }\n) => {\n    if (!editor.selection) {\n        return;\n    }\n\n    Transforms.setNodes(editor, formatOptions, {\n        at: range ? range : editor.selection,\n        match: (n) => Text.isText(n),\n        split: true\n    });\n};\n\n/**\n * Changes the props of the nearest node from the current selection having the specified elementType to the specified props.\n *\n * @param editor\n * @param elementType\n * @param props\n */\nconst changeNearestNodeProps = (\n    editor: CustomEditor,\n    elementType: CustomElementType,\n    props: Partial<CustomElement>\n) => {\n    Transforms.setNodes(editor, props, { match: (n) => (n as CustomElement).type === elementType });\n};\n\nexport const SlateUtils = {\n    removeInlineNode: removeInlineNode,\n    changeCurrentNodeType: changeCurrentNodeType,\n    createNewNode: createNewNode,\n    createNewNodeOfCurrentType: createNewNodeOfCurrentType,\n    wrapNode: wrapNode,\n    unwrapNode: unwrapNode,\n    unwrapLeaf: unwrapLeaf,\n    isCursor: isCursor,\n    isSelection: isSelection,\n    nearestBlockPath: nearestBlockPath,\n    currentBlockStart: currentBlockStart,\n    currentBlockEnd: currentBlockEnd,\n    textSinceBlockStart: textSinceBlockStart,\n    textToBlockEnd: textToBlockEnd,\n    lastPosOf: lastPosOf,\n    cursorIsBehind: cursorIsBehind,\n    currentBlockText: currentBlockText,\n    setCurrentBlockText: setCurrentBlockText,\n    deleteFromLeft: deleteFromLeft,\n    deleteFromRight: deleteFromRight,\n    deleteAt: deleteAt,\n    isChildOf: isChildOf,\n    isChildOfAny: isChildOfAny,\n    nearestElementOfType: nearestElementOfType,\n    currentBlock: currentBlock,\n    currentBlockType: currentBlockType,\n    currentElement: currentElement,\n    currentElementType: currentElementType,\n    currentElementPath: currentElementPath,\n    parentBlock: parentBlock,\n    parentBlockType: parentBlockType,\n    currentLeaf: currentLeaf,\n    isElement: isElement,\n    isLeaf: isLeaf,\n    isRoot: isRoot,\n    isEmpty: isEmpty,\n    isAtRoot: isAtRoot,\n    createRootParagraph: createRootParagraph,\n    createNewline: createNewline,\n    liftToRoot: liftToRoot,\n    setLeafFormat: setLeafFormat,\n    changeNearestNodeProps: changeNearestNodeProps\n};\n", "import React from 'react';\nimport { RenderLeafProps } from 'slate-react';\n\n/**\n * Props for the CustomLeaf component.\n */\nexport type CustomLeafProps = RenderLeafProps;\n\n/**\n * A Custom element for Slate for rendering a leaf that can be used to apply custom styles.\n *\n * @param props\n * @constructor\n */\nexport const CustomLeaf = (props: CustomLeafProps) => {\n    let resultNode = <span {...props.attributes}>{props.children}</span>;\n\n    if (props.leaf.bold) {\n        resultNode = <strong>{resultNode}</strong>;\n    }\n\n    if (props.leaf.italic) {\n        resultNode = <em>{resultNode}</em>;\n    }\n\n    return resultNode;\n};\n", "import { CustomEditor } from '../Types/CustomEditor';\nimport { Editor, Point } from 'slate';\nimport { SlateUtils } from '../Utils/SlateUtils';\nimport { KeyboardEvent } from 'react';\n\n/**\n * Returns whether the text at the editors selection is bold.\n *\n * @param editor\n */\nconst isBoldActive = (editor: CustomEditor): boolean => {\n    return !!Editor.marks(editor)?.bold;\n};\n\n/**\n * Returns whether the text at the editors selection is italic.\n *\n * @param editor\n */\nconst isItalicActive = (editor: CustomEditor): boolean => {\n    return !!Editor.marks(editor)?.italic;\n};\n\n/**\n * Sets the text at the editors selection to bold.\n * If range is given, the text in the specified range will be set to bold.\n * Otherwise the text in the editors selection will be set to bold.\n *\n * @param editor\n * @param range\n */\nconst setBold = (editor: CustomEditor, range?: { anchor: Point; focus: Point }) => {\n    if (!editor.selection) {\n        return;\n    }\n\n    SlateUtils.setLeafFormat(editor, { bold: true }, range);\n};\n\n/**\n * Removes the bold rendering from the editors current cursor.\n *\n * @param editor\n */\nconst unsetBold = (editor: CustomEditor) => {\n    SlateUtils.setLeafFormat(editor, { bold: undefined });\n};\n\n/**\n * Sets the text at the editors selection to italic.\n * If range is given, the text in the specified range will be set to italic.\n * Otherwise the text in the editors selection will be set to italic.\n *\n * @param editor\n * @param range\n */\nconst setItalic = (editor: CustomEditor, range?: { anchor: Point; focus: Point }) => {\n    if (!editor.selection) {\n        return;\n    }\n\n    SlateUtils.setLeafFormat(editor, { italic: true }, range);\n};\n\n/**\n * Removes the italic rendering from the editors current cursor.\n *\n * @param editor\n */\nconst unsetItalic = (editor: CustomEditor) => {\n    SlateUtils.setLeafFormat(editor, { italic: undefined });\n};\n\n/**\n * Toggles the text at the editors selection to be bold or not, depending on whether\n * bold is currently active or not. Note that this method does not use setBold and unsetBold,\n * it sets marks to the editor because this is the method that should be used by the toolbar.\n *\n * @param editor\n */\nconst toggleBold = (editor: CustomEditor) => {\n    if (isBoldActive(editor)) {\n        Editor.removeMark(editor, 'bold');\n    } else {\n        Editor.addMark(editor, 'bold', true);\n    }\n};\n\n/**\n * Toggles the text at the editors selection to be italic or not, depending on whether\n * italic is currently active or not. Note that this method does not use setItalic and unsetItalic,\n * it sets marks to the editor because this is the method that should be used by the toolbar.\n *\n * @param editor\n */\nconst toggleItalic = (editor: CustomEditor) => {\n    if (isItalicActive(editor)) {\n        Editor.removeMark(editor, 'italic');\n    } else {\n        Editor.addMark(editor, 'italic', true);\n    }\n};\n\n/**\n * Handles the bold or italic state at the editors cursor if the user typed a * or _.\n * If the user typed ** or __ and some previous ** or __ exists, the text will be set to bold.\n * If the user typed * or _ and some previous * or _ exists, the text will be set to italic.\n *\n * @param editor\n * @param event\n */\nconst handleBoldAndItalic = (editor: Editor, event: KeyboardEvent<HTMLDivElement>) => {\n    if (!['_', '*'].includes(event.key)) {\n        return;\n    }\n\n    // If the cursor is behind a _ the user typed __, hence he wants to have bold text\n    if (SlateUtils.cursorIsBehind(editor, event.key)) {\n        // Find the beginning position of the text that should be bold\n        const lastPos = SlateUtils.lastPosOf(editor, `${event.key}${event.key}`);\n        if (!lastPos || !editor.selection) {\n            return;\n        }\n\n        setBold(editor, { anchor: lastPos, focus: editor.selection.anchor });\n\n        // This forces the editor at the cursors position to not write bold further\n        Editor.addMark(editor, 'bold', false);\n\n        // Remove shortcuts\n        SlateUtils.deleteAt(editor, lastPos, 2);\n        SlateUtils.deleteFromRight(editor, 1);\n        SlateUtils.deleteAt(editor, editor.selection.anchor, 1);\n        event.preventDefault();\n    } else {\n        // Find the beginning position of the text that should be italic\n        const lastPos = SlateUtils.lastPosOf(editor, event.key, { isolated: true });\n        if (!lastPos || !editor.selection) {\n            return;\n        }\n\n        setItalic(editor, { anchor: lastPos, focus: editor.selection.anchor });\n\n        // This forces the editor at the cursors position to not write italic further\n        Editor.addMark(editor, 'italic', false);\n\n        // Remove shortcuts\n        SlateUtils.deleteAt(editor, lastPos, 1);\n        event.preventDefault();\n    }\n\n    // This is a hack to reset the format at the cursor position.\n};\n\nexport const CustomLeafHelper = {\n    isBoldActive: isBoldActive,\n    isItalicActive: isItalicActive,\n    toggleBold: toggleBold,\n    toggleItalic: toggleItalic,\n    setBold: setBold,\n    setItalic: setItalic,\n    unsetBold: unsetBold,\n    unsetItalic: unsetItalic,\n    handleBoldAndItalic: handleBoldAndItalic\n};\n", "import React, { useContext } from 'react';\nimport styles from './Toolbar.module.css';\nimport { ToolbarButton } from '../ToolbarButton/ToolbarButton';\nimport { UnorderedListHelper } from '../Helpers/UnorderedListHelper';\nimport { OrderedListHelper } from '../Helpers/OrderedListHelper';\nimport { BlockquoteHelper } from '../Helpers/BlockquoteHelper';\nimport { CodeHelper } from '../Helpers/CodeHelper';\nimport { Helpers } from '../Helpers/Helpers';\nimport { CustomLeafHelper } from '../Helpers/CustomLeafHelper';\nimport { UnorderedListItemHelper } from '../Helpers/UnorderedListItemHelper';\nimport { ToolbarButtonSpacer } from '../ToolbarButtonSpacer/ToolbarButtonSpacer';\nimport { Heading1Helper } from '../Helpers/Heading1Helper';\nimport { Heading2Helper } from '../Helpers/Heading2Helper';\nimport { Heading3Helper } from '../Helpers/Heading3Helper';\nimport { Heading4Helper } from '../Helpers/Heading4Helper';\nimport { Heading5Helper } from '../Helpers/Heading5Helper';\nimport { Heading6Helper } from '../Helpers/Heading6Helper';\nimport { useSlate } from 'slate-react';\nimport { HyperlinkToolbarButton } from '../HyperlinkToolbarButton/HyperlinkToolbarButton';\nimport { HyperlinkHelper } from '../Helpers/HyperlinkHelper';\nimport { ImageToolbarButton } from '../ImageToolbarButton/ImageToolbarButton';\nimport { CustomStyle, CustomStyleContext } from '../../../shared/contexts/CustomStyle/Context';\nimport { OrderedListItemHelper } from '../Helpers/OrderedListItemHelper';\n\n/**\n * Props for the ToolBar component.\n */\ninterface ToolbarProps {\n    // Called if the user wants to upload some file, should open the upload modal. The accept parameter are\n    // comma separated mime types. If not given, everything will be accepted.\n    // If forceAttachment is set to true, the result should be an a href targeting\n    // the uploaded file instead of rendered content like images.\n    onUploadRequest?: (accept?: string, forceAttachment?: boolean) => void;\n}\n\n/**\n * Shows a toolbar for the editor.\n * @param props\n * @constructor\n */\nexport const Toolbar = (props: ToolbarProps) => {\n    const editor = useSlate();\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n\n    /**\n     * Called if the user clicks the button to write bold text.\n     * Bolds und \"unbolds\" the text, if the user selected one. Otherwise\n     * the following text will be written in bold.\n     */\n    const onClickBold = () => {\n        CustomLeafHelper.toggleBold(editor);\n    };\n\n    /**\n     * Called if the user clicks the button to write italic text.\n     * Bolds und \"unitalics\" the text, if the user selected one. Otherwise\n     * the following text will be written in italic.\n     */\n    const onClickItalic = () => {\n        CustomLeafHelper.toggleItalic(editor);\n    };\n\n    /**\n     * Called if the user clicks the button to create a heading.\n     * The selected level is the heading size, defining the number of the html h tag.\n     * If the user is currently in a heading block, it will be toggled back to a default paragraph.\n     * Otherwise the blcok will be set to the heading of the specified level.\n     *\n     * @param level\n     */\n    const onClickHeading = (level: number) => {\n        //@ts-ignore can not be indexed, but this will obviously work\n        Helpers[`heading-${level}`].toggle(editor, { actor: 'toolbar' });\n    };\n\n    /**\n     * Called if the user clicks the button to create an unordered list.\n     * Sets the current block the user is located in to an unordered list, if it is not yet a list.\n     * Otherwise it will be set back to paragraph.\n     */\n    const onClickUnorderedList = () => {\n        // This is a special case because we want to have the cursor in a list item directly\n        UnorderedListItemHelper.toggle(editor, { actor: 'toolbar' });\n    };\n\n    /**\n     * Called if the user clicks the button to create an ordered list.\n     * Sets the current block the user is located in to an ordered list, if it is not yet a list.\n     * Otherwise it will be set back to paragraph.\n     */\n    const onClickOrderedList = () => {\n        // This is a special case because we want to have the cursor in a list item directly\n        OrderedListItemHelper.toggle(editor, { actor: 'toolbar' });\n    };\n\n    /**\n     * Called if the user clicks the button to create a blockquote.\n     * Sets the current block the user is located in to a blockquote, if it is not yet a blockquote.\n     * Otherwise it will be set back to paragraph.\n     */\n    const onClickBlockquote = () => {\n        BlockquoteHelper.toggle(editor, { actor: 'toolbar' });\n    };\n\n    /**\n     * Called if the user clicks the button to create a code block.\n     * Sets the current block the user is located in to a code block, if it is not yet a code block.\n     * Otherwise it will be set back to paragraph.\n     */\n    const onClickCode = () => {\n        CodeHelper.toggle(editor, { actor: 'toolbar' });\n    };\n\n    /**\n     * Called if the user clicks the button to upload a file.\n     * Calls the callback to open the upload dialog. The upload will be force to be shown\n     * as attachment instead of rendered content.\n     */\n    const onClickUpload = () => {\n        if (!props.onUploadRequest) return;\n\n        props.onUploadRequest(undefined, true);\n    };\n\n    /**\n     * Holds for all buttons the status if it should be shown as active.\n     */\n    const activeStatus: Record<string, boolean> = {\n        bold: CustomLeafHelper.isBoldActive(editor),\n        italic: CustomLeafHelper.isItalicActive(editor),\n        'heading-1': Heading1Helper.active(editor),\n        'heading-2': Heading2Helper.active(editor),\n        'heading-3': Heading3Helper.active(editor),\n        'heading-4': Heading4Helper.active(editor),\n        'heading-5': Heading5Helper.active(editor),\n        'heading-6': Heading6Helper.active(editor),\n        'unordered-list': UnorderedListHelper.active(editor),\n        'ordered-list': OrderedListHelper.active(editor),\n        blockquote: BlockquoteHelper.active(editor),\n        code: CodeHelper.active(editor),\n        hyperlink: HyperlinkHelper.active(editor)\n    };\n\n    return (\n        <div className={`${styles.container} ${customStyle?.toolbar?.containerClassName || ''}`}>\n            <div className={styles.innerContainer}>\n                {/* format options */}\n                <ToolbarButton icon={'bold'} onClick={onClickBold} active={activeStatus['bold']} />\n                <ToolbarButton icon={'italic'} onClick={onClickItalic} active={activeStatus['italic']} />\n                <ToolbarButtonSpacer />\n\n                {/* headings */}\n                {[1, 2, 3, 4, 5, 6].map((headingLevel) => (\n                    <ToolbarButton\n                        key={headingLevel}\n                        onClick={() => onClickHeading(headingLevel)}\n                        text={`H${headingLevel}`}\n                        active={activeStatus[`heading-${headingLevel}`]}\n                    />\n                ))}\n                <ToolbarButtonSpacer />\n\n                {/* lists */}\n                <ToolbarButton\n                    icon={'unordered-list'}\n                    onClick={onClickUnorderedList}\n                    active={activeStatus['unordered-list']}\n                />\n                <ToolbarButton\n                    icon={'ordered-list'}\n                    onClick={onClickOrderedList}\n                    active={activeStatus['ordered-list']}\n                />\n                <ToolbarButtonSpacer />\n\n                {/* blocks */}\n                <ToolbarButton icon={'blockquote'} onClick={onClickBlockquote} active={activeStatus['blockquote']} />\n                <ToolbarButton icon={'code'} onClick={onClickCode} active={activeStatus['code']} />\n                <ToolbarButtonSpacer />\n\n                {/* uploads or links */}\n                <HyperlinkToolbarButton />\n                <ImageToolbarButton onUploadRequest={props.onUploadRequest} />\n                {props.onUploadRequest && <ToolbarButton icon={'upload'} onClick={onClickUpload} active={false} />}\n            </div>\n        </div>\n    );\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/components/MarkdownEditor/Toolbar/Toolbar.module.css\";\n\nexport default {\n  \"container\": \"Toolbar-module__container_rf3kvG__030\",\n  \"innerContainer\": \"Toolbar-module__innerContainer_rf3kvG__030\"\n};\n      ", "import React, { useMemo, MouseEvent, useContext } from 'react';\nimport styles from './ToolbarButton.module.css';\nimport { FaBold, FaItalic, FaListOl, FaList, FaQuoteLeft, FaCode, FaUpload, FaLink, FaImage } from 'react-icons/fa';\nimport { CustomStyle, CustomStyleContext } from '../../../shared/contexts/CustomStyle/Context';\n\n/**\n * Props for the ToolbarButton component.\n */\ninterface ToolbarButtonProps {\n    // If given, the font-awesome icon will be shown\n    icon?:\n        | 'bold'\n        | 'blockquote'\n        | 'code'\n        | 'italic'\n        | 'ordered-list'\n        | 'unordered-list'\n        | 'upload'\n        | 'hyperlink'\n        | 'image';\n\n    // If no icon is given, the text will be shown\n    text?: string;\n\n    // Indicates whether the button should be rendered as \"currently active\" button\n    active?: boolean;\n\n    // Called if the user clicks the button\n    onClick: () => void;\n}\n\n/**\n * A button for the toolbar of the editor.\n *\n * @param props\n * @constructor\n */\nexport const ToolbarButton = (props: ToolbarButtonProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n\n    const icon = useMemo(() => {\n        switch (props.icon) {\n            case 'bold': {\n                return <FaBold />;\n            }\n\n            case 'italic': {\n                return <FaItalic />;\n            }\n\n            case 'ordered-list': {\n                return <FaListOl />;\n            }\n\n            case 'unordered-list': {\n                return <FaList />;\n            }\n\n            case 'blockquote': {\n                return <FaQuoteLeft />;\n            }\n\n            case 'code': {\n                return <FaCode />;\n            }\n\n            case 'upload': {\n                return <FaUpload />;\n            }\n\n            case 'hyperlink': {\n                return <FaLink />;\n            }\n\n            case 'image': {\n                return <FaImage />;\n            }\n        }\n    }, [props.icon]);\n\n    /**\n     * Called if the mousedown event of the button was triggered.\n     * Calls preventDefault to make the editor window not to loose focus if the button was pressed.\n     *\n     * @param event\n     */\n    const onMouseDown = (event: MouseEvent<HTMLButtonElement>) => {\n        event.preventDefault();\n    };\n\n    return (\n        <button\n            onMouseDown={onMouseDown}\n            className={`${styles.button} ${customStyle?.toolbar?.buttonClassName || ''} ${\n                props.active ? 'active' : ''\n            }`}\n            onClick={props.onClick}\n        >\n            {icon ? icon : props.text}\n        </button>\n    );\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/components/MarkdownEditor/ToolbarButton/ToolbarButton.module.css\";\n\nexport default {\n  \"button\": \"ToolbarButton-module__button_U5m4DG__030\"\n};\n      ", "import { createContext } from 'react';\n\n/**\n * Defines the value that is saved in the context.\n * Holds all css classes and other attributes needed to customize the style of ReMaWy.\n */\nexport interface CustomStyle {\n    // Holds several texts for buttons or other content\n    texts?: {\n        // Used by the label in the image and hyperlink forms\n        url?: string;\n\n        // Used by the submit buttons in the image and hyperlink forms\n        insert?: string;\n\n        // Used by the remove buttons in the image and hyperlink forms\n        remove?: string;\n\n        // Used by the upload button in the image form\n        upload?: string;\n\n        // The title shown in the header of the modal to upload a file\n        uploadModalHeaderTitle?: string;\n\n        // Used by the upload modal if someone tried to insert a not accepted file type\n        invalidFileTypeError?: string;\n\n        // Used by the upload modal if someone trief to upload a too large file\n        maxFileSizeError?: string;\n    };\n\n    // Styles for the editor itself\n    editor?: {\n        // Optional class name that is passed to the outer container, holding the toolbar and the editor\n        containerClassName?: string;\n\n        // Optional css class name that is passed to the editor container, holding the content\n        editorContainerClassName?: string;\n    };\n\n    // Styles for the toolbar of the editor\n    toolbar?: {\n        // Optional css class name that is passed to the toolbar container\n        containerClassName?: string;\n\n        // Optional css class name that is passed to the toolbar buttons\n        buttonClassName?: string;\n    };\n\n    // popovers for some buttons that hold additional forms like hyperlink or image buttons.\n    popover?: {\n        // Optional css class name that is passed to the outer container of popovers.\n        // This is the outer container having the position relative attribute.\n        containerClassName?: string;\n\n        // Optional css class name that is passed to the inner container of popovers.\n        // This is the inner container having the position absolute attribute.\n        innerContainerClassName?: string;\n    };\n\n    // Styles for the upload modal of the editor\n    modal?: {\n        // Optional css class that is passed to the modal outer container (the absolute container)\n        containerClassName?: string;\n\n        // Optional css class that is passed to the modal inner container, holding the upload form (the relative container)\n        innerContainerClassName?: string;\n\n        // Optional css class that is passed to the modal header holding the close button\n        headerContainerClassName?: string;\n\n        // Optional css class name that is passed to the modal body holding the form\n        bodyContainerClassName?: string;\n    };\n\n    // Styles for additional forms like the ones in the popovers for the image or hyperlink buttons\n    forms?: {\n        // Optional css class name for the container of the form\n        containerClassName?: string;\n\n        // Optional css class for a form group holding a label, the field and an error message\n        groupClassName?: string;\n\n        // Optional css class for a label in a form group\n        labelClassName?: string;\n\n        // Optional css class for a text input in a form group\n        inputClassName?: string;\n\n        // Optional css class for a error in a form\n        errorClassName?: string;\n\n        // Optional css class for the container holding the buttons like the submit button\n        buttonsContainerClassName?: string;\n\n        // Optional css class for a button in a form.\n        // Note that the colors can be changed by chaining this class name with a class of the button type.\n        // Available types are primary, secondary and danger\n        buttonClassName?: string;\n    };\n}\n\nexport const CustomStyleContext = createContext<CustomStyle | undefined>(undefined);\n", "import { CustomElement, CustomElementType } from '../Types/CustomElement';\nimport { Descendant, Editor, Element } from 'slate';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { SlateUtils } from './SlateUtils';\nimport { KeyboardEvent } from 'react';\nimport { ToggleOptions } from '../Types/CustomHelper';\n\n/**\n * Can be used by helpers to check whether the element of the specified elementType is\n * currently active in the current block of the editors cursor.\n *\n * @param editor\n * @param elementType\n */\nconst defaultIsActive = (editor: CustomEditor, elementType: CustomElementType): boolean => {\n    const [match] = Editor.nodes(editor, {\n        match: (n) => (n as Element).type === elementType\n    });\n\n    return !!match;\n};\n\n/**\n * Can be used by helpers to toggle the element at the editors current cursor between the\n * specified elementType and default paragraph.\n *\n * @param editor\n * @param elementType\n */\nconst defaultToggle = (editor: CustomEditor, elementType: CustomElementType): void => {\n    const isActive = defaultIsActive(editor, elementType);\n\n    if (isActive) {\n        SlateUtils.changeCurrentNodeType(editor, 'paragraph');\n    } else {\n        SlateUtils.changeCurrentNodeType(editor, elementType);\n    }\n};\n\n/**\n * Can be used by helpers to toggle the element at the editors current cursor between the\n * specified elementType and default paragraph.\n * The element is expected to be only allowed at the root, meaing the element must not be in a list or\n * some other element.\n *\n * @param editor\n * @param elementType\n */\nconst toggleAtRoot = (editor: CustomEditor, elementType: CustomElementType): void => {\n    const isActive = defaultIsActive(editor, elementType);\n\n    // Not active, first get to root and then set element\n    if (!isActive) {\n        SlateUtils.liftToRoot(editor);\n\n        return SlateUtils.changeCurrentNodeType(editor, elementType);\n    }\n\n    // Active should be only in root, hence we can deactivate it by setting only to paragraph\n    SlateUtils.changeCurrentNodeType(editor, 'paragraph');\n};\n\n/**\n * Can be used by helpers to toggle nodes of elementType inline.\n * The node is converted to a leaf if it is currently active, if possible.\n * Otherwise the current node tyoe is set to elementType.\n * The props are merged with the node types props if the node type is activated.\n * If defaultChildren is given, the children will be passed if the user did not select some text.\n *\n * @param editor\n * @param elementType\n * @param props\n * @param defaultChildren\n */\nconst toggleInlineNode = (\n    editor: CustomEditor,\n    elementType: CustomElementType,\n    props?: Partial<CustomElement>,\n    defaultChildren?: Descendant[]\n): void => {\n    const isActive = defaultIsActive(editor, elementType);\n\n    if (isActive) {\n        SlateUtils.removeInlineNode(editor);\n    } else {\n        const defaultProps =\n            defaultChildren && SlateUtils.isCursor(editor) ? { ...props, children: defaultChildren } : props;\n\n        SlateUtils.changeCurrentNodeType(editor, elementType, defaultProps);\n    }\n};\n\n/**\n * Can be used by helpers to toggle the element at the editors current cursor between the\n * specified elementType and default paragraph.\n * The element is expected to be allowed in list items, meaning that lists can be used to eg. indent the element.\n *\n * @param editor\n * @param elementType\n */\nconst toggleWithListAllowed = (editor: CustomEditor, elementType: CustomElementType) => {\n    const isActive = defaultIsActive(editor, elementType);\n    const isInOrderedList = SlateUtils.isChildOf(editor, 'ordered-list-item');\n    const isInUnorderedList = SlateUtils.isChildOf(editor, 'unordered-list-item');\n    const isInList = isInOrderedList || isInUnorderedList;\n\n    if (isActive && isInList) {\n        return SlateUtils.unwrapLeaf(editor);\n    } else if (isActive && !isInList) {\n        return SlateUtils.changeCurrentNodeType(editor, 'paragraph');\n    }\n\n    SlateUtils.changeCurrentNodeType(editor, elementType);\n\n    if (!isInList) return;\n\n    SlateUtils.wrapNode(editor, isInOrderedList ? 'ordered-list-item' : 'unordered-list-item');\n};\n\n/**\n * Can be used by helpers in onEnter callbacks to create a newline in the current block if the\n * user pressed shift and enter at once. If the user did not press shift, a new paragraph at\n * root level will be created.\n *\n * @param editor\n * @param event\n */\nconst onEnterWithShiftLinebreak = (editor: CustomEditor, event: KeyboardEvent) => {\n    if (event.shiftKey) {\n        SlateUtils.createNewline(editor);\n    } else {\n        SlateUtils.createRootParagraph(editor);\n    }\n\n    event.preventDefault();\n};\n\n/**\n * Can be used by helpers in onEnter callbacks for elements that are allowed to be in lists.\n * If the element is in a list, the element will be unwrapped to disable it for the next list item.\n * If the element is not in a list, the default onEnter action will be executed that allows pressing shift\n * for only newline.\n *\n * @param editor\n * @param event\n */\nconst onEnterWithListAndNewlineAllowed = (editor: CustomEditor, event: KeyboardEvent) => {\n    const isInOrderedList = SlateUtils.isChildOf(editor, 'ordered-list-item');\n    const isInUnorderedList = SlateUtils.isChildOf(editor, 'unordered-list-item');\n    const isInList = isInOrderedList || isInUnorderedList;\n\n    // If the item is not in a list, do the default behavior\n    // If shiftKey is pressed we just want to have a newline, that is also handled in the default function\n    if (!isInList || event.shiftKey) {\n        return onEnterWithShiftLinebreak(editor, event);\n    }\n\n    // If the node is in a list and shift is not pressed\n    if (isInList) {\n        SlateUtils.createNewNodeOfCurrentType(editor);\n\n        SlateUtils.changeCurrentNodeType(editor, isInOrderedList ? 'ordered-list-item' : 'unordered-list-item');\n\n        return event.preventDefault();\n    }\n\n    onEnterWithShiftLinebreak(editor, event);\n};\n\n/**\n * Deactivates the list item at the cursor position of the editor, by setting it to paragraph\n * and removing all indents.\n *\n * @param editor\n * @param listType\n */\nconst deactivateListItem = (editor: CustomEditor, listType: 'ordered-list' | 'unordered-list') => {\n    // Remove lists and indented lists until we are in the \"root\"\n    do {\n        SlateUtils.unwrapNode(editor);\n    } while (SlateUtils.parentBlockType(editor) === listType);\n\n    // Change the list-item element to paragraph\n    SlateUtils.changeCurrentNodeType(editor, 'paragraph');\n};\n\n/**\n * Toggles the rendering of the ListItemElement in the specified editor in a list of the specified listType.\n *\n * @param editor\n * @param listType\n * @param options\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst toggleListItem = (editor: CustomEditor, listType: 'ordered-list' | 'unordered-list', options?: ToggleOptions) => {\n    const listItemType = listType === 'ordered-list' ? 'ordered-list-item' : 'unordered-list-item';\n\n    // currently we are in a list item, hence we need to deactivate it.\n    if (defaultIsActive(editor, listItemType)) {\n        return deactivateListItem(editor, listType);\n    }\n\n    if (!SlateUtils.isChildOf(editor, listType)) {\n        SlateUtils.wrapNode(editor, listType);\n    }\n\n    SlateUtils.changeCurrentNodeType(editor, listItemType);\n};\n\n/**\n * Called if the user presses tab in a list-item element of the specified listType.\n * Forces the list to get into a sub list, to enable indent behavior.\n *\n * @param editor\n * @param listType\n * @param event\n */\nconst onTabListItem = (editor: CustomEditor, listType: 'ordered-list' | 'unordered-list', event: KeyboardEvent) => {\n    // if shift is pressed, the list current list should be unintended\n    if (event.shiftKey) {\n        SlateUtils.unwrapNode(editor);\n\n        // If the parent is no list (after lifting), convert it to paragraph\n        // If the parentElement is null, it is assumed that the parent element is the root node, hence\n        // we want to convert it back here, too\n        const parentBlock = SlateUtils.parentBlock(editor);\n        if (!parentBlock || parentBlock.type !== listType) {\n            SlateUtils.changeCurrentNodeType(editor, 'paragraph');\n        }\n\n        // if shift is not pressed, the list should be intended\n    } else {\n        const parentBlock = SlateUtils.parentBlock(editor);\n        const currentBlock = SlateUtils.currentBlock(editor);\n        if (!currentBlock || !parentBlock) return;\n\n        SlateUtils.wrapNode(editor, listType);\n    }\n\n    // prevent default tab handler from being processed\n    event.preventDefault();\n};\n\n/**\n * Overwrites the default behavior if the user presses enter in a list item in the specified listType.\n * If the curent textnode is empty, a new paragraph will be created. This should be the case if the user\n * is inside an empty list-entry.\n * Otherwise a new list entry will be created. This is done by just doing nothing, because this shoul cause slate\n * to do its default action that is creating a new list-entry.\n *\n * @param editor\n * @param listType\n * @param event\n */\nconst onEnterListItem = (editor: CustomEditor, listType: 'ordered-list' | 'unordered-list', event: KeyboardEvent) => {\n    // only remove list item it enter was pressed twice\n    const textSinceBlockStart = SlateUtils.textSinceBlockStart(editor);\n    if (textSinceBlockStart !== '') return;\n\n    deactivateListItem(editor, listType);\n\n    // Prevent default slate action\n    event.preventDefault();\n};\n\nexport const HelperUtils = {\n    defaultIsActive: defaultIsActive,\n    defaultToggle: defaultToggle,\n    toggleInlineNode: toggleInlineNode,\n    toggleAtRoot: toggleAtRoot,\n    toggleWithListAllowed: toggleWithListAllowed,\n    onEnterWithShiftLinebreak: onEnterWithShiftLinebreak,\n    onEnterWithListAndNewlineAllowed: onEnterWithListAndNewlineAllowed,\n    toggleListItem: toggleListItem,\n    onTabListItem: onTabListItem,\n    onEnterListItem: onEnterListItem\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\n\n/**\n * Returns whether the UnorderedListElement is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'unordered-list');\n};\n\n/**\n * Toggles the rendering of the UnorderedListElement in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.defaultToggle(editor, 'unordered-list');\n};\n\nexport const UnorderedListHelper: CustomHelper = {\n    elementType: 'unordered-list',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\n\n/**\n * Returns whether the OrderedListElement is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'ordered-list');\n};\n\n/**\n * Toggles the rendering of the OrderedListElement in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.defaultToggle(editor, 'ordered-list');\n};\n\nexport const OrderedListHelper: CustomHelper = {\n    elementType: 'ordered-list',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { KeyboardEvent } from 'react';\n\n/**\n * Returns whether the BlockQuoteElement is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'blockquote');\n};\n\n/**\n * Toggles the rendering of the BlockQuoteElement in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.toggleWithListAllowed(editor, 'blockquote');\n};\n\n/**\n * Overwrites the behavior of the editor on pressing enter in a blockuote element.\n * If the user presses shift and enter, a new line will be created.\n * If the user only presses enter, a new empty paragraph will be created.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    HelperUtils.onEnterWithListAndNewlineAllowed(editor, event);\n};\n\nexport const BlockquoteHelper: CustomHelper = {\n    elementType: 'blockquote',\n    shortcutText: '>',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onEnter: onEnter\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { KeyboardEvent } from 'react';\n\n/**\n * Returns whether the CodeElement is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'code');\n};\n\n/**\n * Toggles the rendering of the CodeElement in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.toggleWithListAllowed(editor, 'code');\n};\n\n/**\n * Overwrites the behavior of the editor on pressing enter in a code element.\n * If the user presses shift and enter, a new line will be created.\n * If the user only presses enter, a new empty paragraph will be created.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    HelperUtils.onEnterWithListAndNewlineAllowed(editor, event);\n};\n\nexport const CodeHelper: CustomHelper = {\n    elementType: 'code',\n    shortcutText: '```',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onEnter: onEnter\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { KeyboardEvent } from 'react';\nimport { SlateUtils } from '../Utils/SlateUtils';\n\n/**\n * Returns whether the Heading1Element is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'heading-1');\n};\n\n/**\n * Toggles the rendering of the Heading1Element in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.toggleAtRoot(editor, 'heading-1');\n};\n\n/**\n * Replaces the default behavior of pressing enter.\n * Always creates a new paragraph instead of creating a new header.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    SlateUtils.createRootParagraph(editor);\n\n    // prevent the default slate action from creating a new heading\n    event.preventDefault();\n};\n\nexport const Heading1Helper: CustomHelper = {\n    elementType: 'heading-1',\n    shortcutText: '#',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onEnter: onEnter\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { KeyboardEvent } from 'react';\nimport { SlateUtils } from '../Utils/SlateUtils';\n\n/**\n * Returns whether the Heading2Element is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'heading-2');\n};\n\n/**\n * Toggles the rendering of the Heading2Element in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.toggleAtRoot(editor, 'heading-2');\n};\n\n/**\n * Replaces the default behavior of pressing enter.\n * Always creates a new paragraph instead of creating a new header.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    SlateUtils.createRootParagraph(editor);\n\n    // prevent the default slate action from creating a new heading\n    event.preventDefault();\n};\n\nexport const Heading2Helper: CustomHelper = {\n    elementType: 'heading-2',\n    shortcutText: '##',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onEnter: onEnter\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { KeyboardEvent } from 'react';\nimport { SlateUtils } from '../Utils/SlateUtils';\n\n/**\n * Returns whether the Heading3Element is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'heading-3');\n};\n\n/**\n * Toggles the rendering of the Heading3Element in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.toggleAtRoot(editor, 'heading-3');\n};\n\n/**\n * Replaces the default behavior of pressing enter.\n * Always creates a new paragraph instead of creating a new header.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    SlateUtils.createRootParagraph(editor);\n\n    // prevent the default slate action from creating a new heading\n    event.preventDefault();\n};\n\nexport const Heading3Helper: CustomHelper = {\n    elementType: 'heading-3',\n    shortcutText: '###',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onEnter: onEnter\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { KeyboardEvent } from 'react';\nimport { SlateUtils } from '../Utils/SlateUtils';\n\n/**\n * Returns whether the Heading4Element is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'heading-4');\n};\n\n/**\n * Toggles the rendering of the Heading4Element in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.toggleAtRoot(editor, 'heading-4');\n};\n\n/**\n * Replaces the default behavior of pressing enter.\n * Always creates a new paragraph instead of creating a new header.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    SlateUtils.createRootParagraph(editor);\n\n    // prevent the default slate action from creating a new heading\n    event.preventDefault();\n};\n\nexport const Heading4Helper: CustomHelper = {\n    elementType: 'heading-4',\n    shortcutText: '####',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onEnter: onEnter\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { KeyboardEvent } from 'react';\nimport { SlateUtils } from '../Utils/SlateUtils';\n\n/**\n * Returns whether the Heading5Element is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'heading-5');\n};\n\n/**\n * Toggles the rendering of the Heading5Element in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.toggleAtRoot(editor, 'heading-5');\n};\n\n/**\n * Replaces the default behavior of pressing enter.\n * Always creates a new paragraph instead of creating a new header.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    SlateUtils.createRootParagraph(editor);\n\n    // prevent the default slate action from creating a new heading\n    event.preventDefault();\n};\n\nexport const Heading5Helper: CustomHelper = {\n    elementType: 'heading-5',\n    shortcutText: '#####',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onEnter: onEnter\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { KeyboardEvent } from 'react';\nimport { SlateUtils } from '../Utils/SlateUtils';\n\n/**\n * Returns whether the Heading6Element is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'heading-6');\n};\n\n/**\n * Toggles the rendering of the Heading6Element in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    HelperUtils.toggleAtRoot(editor, 'heading-6');\n};\n\n/**\n * Replaces the default behavior of pressing enter.\n * Always creates a new paragraph instead of creating a new header.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    SlateUtils.createRootParagraph(editor);\n\n    // prevent the default slate action from creating a new heading\n    event.preventDefault();\n};\n\nexport const Heading6Helper: CustomHelper = {\n    elementType: 'heading-6',\n    shortcutText: '######',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onEnter: onEnter\n};\n", "import { CustomHelper, ToggleOptions } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { KeyboardEvent } from 'react';\nimport { HelperUtils } from '../Utils/HelperUtils';\n\n/**\n * Returns whether the ListItemElement is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'unordered-list-item');\n};\n\n/**\n * Toggles the rendering of the ListItemElement in the specified editor.\n *\n * @param editor\n * @param options\n */\nconst toggle = (editor: CustomEditor, options?: ToggleOptions) => {\n    HelperUtils.toggleListItem(editor, 'unordered-list', options);\n};\n\n/**\n * Called if the user presses tab in a list-item element.\n * Forces the list to get into a sub list, to enable indent behavior.\n *\n * @param editor\n * @param event\n */\nconst onTab = (editor: CustomEditor, event: KeyboardEvent) => {\n    HelperUtils.onTabListItem(editor, 'unordered-list', event);\n};\n\n/**\n * Overwrites the default behavior if the user presses enter in a list item.\n * If the curent textnode is empty, a new paragraph will be created. This should be the case if the user\n * is inside an empty list-entry.\n * Otherwise a new list entry will be created. This is done by just doing nothing, because this shoul cause slate\n * to do its default action that is creating a new list-entry.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    HelperUtils.onEnterListItem(editor, 'unordered-list', event);\n};\n\nexport const UnorderedListItemHelper: CustomHelper = {\n    elementType: 'unordered-list-item',\n    shortcutText: '*',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onTab: onTab,\n    onEnter: onEnter\n};\n", "import { CustomHelper } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { KeyboardEvent } from 'react';\nimport { SlateUtils } from '../Utils/SlateUtils';\nimport { HelperUtils } from '../Utils/HelperUtils';\n\n/**\n * Returns whether the ParagraphElement is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'paragraph');\n};\n\n/**\n * Toggles the rendering of the ParagraphElement in the specified editor.\n *\n * @param editor\n */\nconst toggle = (editor: CustomEditor) => {\n    SlateUtils.changeCurrentNodeType(editor, 'paragraph');\n};\n\n/**\n * Overwrites the behavior of the editor on pressing enter in a paragraph element.\n * If the user presses shift and enter, a new line will be created.\n * If the user only presses enter, a new empty paragraph will be created.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    HelperUtils.onEnterWithShiftLinebreak(editor, event);\n};\n\nexport const ParagraphHelper: CustomHelper = {\n    elementType: 'paragraph',\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onEnter: onEnter\n};\n", "import { CustomHelper, ToggleOptions } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { CustomElement } from '../Types/CustomElement';\nimport { SlateUtils } from '../Utils/SlateUtils';\n\n/**\n * Returns whether the Hyperlink is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'hyperlink');\n};\n\n/**\n * Toggles the rendering of the Hyperlink in the specified editor.\n *\n * @param editor\n * @param options\n * @param props\n */\nconst toggle = (editor: CustomEditor, options?: ToggleOptions, props?: Partial<CustomElement>) => {\n    if (options?.actor == 'shortcut' && options.actorShortcutMatch) {\n        if (options.actorShortcutMatch.length < 3) return;\n\n        const linkText = options.actorShortcutMatch[1];\n        const href = options.actorShortcutMatch[2];\n\n        SlateUtils.createNewNode(editor, 'hyperlink', {\n            children: [{ text: linkText }],\n            props: { href: href },\n            createFollowingText: ' '\n        });\n    } else {\n        HelperUtils.toggleInlineNode(editor, 'hyperlink', props, [{ text: 'Link' }]);\n    }\n};\n\n/**\n * Inserts a hyperlink having the specified props at the current cursors position, or updates\n * the hyperluink at the current cursor position, if it already exists.\n *\n * @param editor\n * @param props\n */\nconst onUpsert = (editor: CustomEditor, props: Partial<CustomElement>) => {\n    if (!SlateUtils.isChildOf(editor, 'hyperlink')) {\n        // If there is text selected, but no hyperlink, just \"toggle\" the hyperlink by wrapping the seletced content into it\n        if (SlateUtils.isSelection(editor)) {\n            return SlateUtils.wrapNode(editor, 'hyperlink', props);\n\n            // If there is no text selected, but no hyperlink, create a new one to prevent the whole block from being toggled\n        } else {\n            return SlateUtils.createNewNode(editor, 'hyperlink', {\n                children: props.children,\n                props: props,\n                voids: true,\n                createFollowingText: ' '\n            });\n        }\n    }\n\n    // update the href at the nearest hyperlink, if the current cursor is already in some link\n    SlateUtils.changeNearestNodeProps(editor, 'hyperlink', props);\n};\n\nexport const HyperlinkHelper: CustomHelper = {\n    elementType: 'hyperlink',\n    shortcutRegex: /\\[(.+)]\\((.+)\\)$/,\n    isVoid: false,\n    isInline: true,\n    active: active,\n    toggle: toggle,\n    onUpsert: onUpsert\n};\n", "import { CustomHelper, ToggleOptions } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { HelperUtils } from '../Utils/HelperUtils';\nimport { CustomElement } from '../Types/CustomElement';\nimport { SlateUtils } from '../Utils/SlateUtils';\n\n/**\n * Returns whether the Image is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'image');\n};\n\n/**\n * Toggles the rendering of the Image in the specified editor.\n *\n * @param editor\n * @param options\n * @param props\n */\nconst toggle = (editor: CustomEditor, options?: ToggleOptions, props?: Partial<CustomElement>) => {\n    if (options?.actor == 'shortcut' && options.actorShortcutMatch) {\n        if (options.actorShortcutMatch.length < 3) return;\n\n        const altText = options.actorShortcutMatch[1];\n        const src = options.actorShortcutMatch[2];\n\n        SlateUtils.createNewNode(editor, 'image', {\n            props: { src: src, altText: altText },\n            createFollowingText: ' '\n        });\n    } else {\n        HelperUtils.toggleInlineNode(editor, 'image', props);\n    }\n};\n\n/**\n * Inserts a image having the specified props at the current cursors position, or updates\n * the image at the current cursor position, if it already exists.\n *\n * @param editor\n * @param props\n */\nconst onUpsert = (editor: CustomEditor, props: Partial<CustomElement>) => {\n    const currentElement = SlateUtils.currentElement(editor);\n\n    // this is an error case, because there should be any element\n    if (!currentElement) return;\n\n    // Existing image needs only to be updated\n    if (currentElement.type === 'image') {\n        SlateUtils.changeNearestNodeProps(editor, 'image', props);\n\n        // Create a new image at the current position\n    } else {\n        SlateUtils.createNewNode(editor, 'image', {\n            props: props,\n            voids: true,\n            createFollowingText: ' '\n        });\n    }\n};\n\nexport const ImageHelper: CustomHelper = {\n    elementType: 'image',\n    shortcutRegex: /!\\[(.+)]\\((.+)\\)$/,\n    isVoid: true,\n    isInline: true,\n    active: active,\n    toggle: toggle,\n    onUpsert: onUpsert\n};\n", "import { CustomHelper, ToggleOptions } from '../Types/CustomHelper';\nimport { CustomEditor } from '../Types/CustomEditor';\nimport { KeyboardEvent } from 'react';\nimport { HelperUtils } from '../Utils/HelperUtils';\n\n/**\n * Returns whether the ListItemElement is currently active in the specified editor.\n *\n * @param editor\n */\nconst active = (editor: CustomEditor): boolean => {\n    return HelperUtils.defaultIsActive(editor, 'ordered-list-item');\n};\n\n/**\n * Toggles the rendering of the ListItemElement in the specified editor.\n *\n * @param editor\n * @param options\n */\nconst toggle = (editor: CustomEditor, options?: ToggleOptions) => {\n    HelperUtils.toggleListItem(editor, 'ordered-list', options);\n};\n\n/**\n * Called if the user presses tab in a list-item element.\n * Forces the list to get into a sub list, to enable indent behavior.\n *\n * @param editor\n * @param event\n */\nconst onTab = (editor: CustomEditor, event: KeyboardEvent) => {\n    HelperUtils.onTabListItem(editor, 'ordered-list', event);\n};\n\n/**\n * Overwrites the default behavior if the user presses enter in a list item.\n * If the curent textnode is empty, a new paragraph will be created. This should be the case if the user\n * is inside an empty list-entry.\n * Otherwise a new list entry will be created. This is done by just doing nothing, because this shoul cause slate\n * to do its default action that is creating a new list-entry.\n *\n * @param editor\n * @param event\n */\nconst onEnter = (editor: CustomEditor, event: KeyboardEvent) => {\n    HelperUtils.onEnterListItem(editor, 'ordered-list', event);\n};\n\nexport const OrderedListItemHelper: CustomHelper = {\n    elementType: 'ordered-list-item',\n    shortcutRegex: /^\\d+\\.$/,\n    isVoid: false,\n    isInline: false,\n    active: active,\n    toggle: toggle,\n    onTab: onTab,\n    onEnter: onEnter\n};\n", "import { CustomElementType } from '../Types/CustomElement';\nimport { CustomHelper } from '../Types/CustomHelper';\nimport { BlockquoteHelper } from './BlockquoteHelper';\nimport { CodeHelper } from './CodeHelper';\nimport { Heading1Helper } from './Heading1Helper';\nimport { Heading2Helper } from './Heading2Helper';\nimport { Heading3Helper } from './Heading3Helper';\nimport { Heading4Helper } from './Heading4Helper';\nimport { Heading5Helper } from './Heading5Helper';\nimport { Heading6Helper } from './Heading6Helper';\nimport { UnorderedListItemHelper } from './UnorderedListItemHelper';\nimport { OrderedListHelper } from './OrderedListHelper';\nimport { ParagraphHelper } from './ParagraphHelper';\nimport { UnorderedListHelper } from './UnorderedListHelper';\nimport { HyperlinkHelper } from './HyperlinkHelper';\nimport { ImageHelper } from './ImageHelper';\nimport { OrderedListItemHelper } from './OrderedListItemHelper';\n\n/**\n * Holds all available Helpers that can render an element.\n */\nexport const HelpersArray: CustomHelper[] = [\n    BlockquoteHelper,\n    CodeHelper,\n    Heading1Helper,\n    Heading2Helper,\n    Heading3Helper,\n    Heading4Helper,\n    Heading5Helper,\n    Heading6Helper,\n\n    // image helper needs to be before hyperlink helper, because the shortcut of hyperlink is a subset of the shortcut of image\n    ImageHelper,\n    HyperlinkHelper,\n\n    OrderedListHelper,\n    OrderedListItemHelper,\n    ParagraphHelper,\n    UnorderedListHelper,\n    UnorderedListItemHelper\n];\n\n/**\n * Holds a map of { elementType: helper } to make all helpers accessible by its type more easily.\n */\n// @ts-ignore all helpers are defined in the HelpersArray, hence we have all values available here\nconst Helpers: Record<CustomElementType, CustomHelper> = {};\n\nHelpersArray.forEach((helper) => {\n    Helpers[helper.elementType] = helper;\n});\n\nexport { Helpers };\n\n/**\n * Holds all available helpers rendering block elements.\n */\nexport const BlockHelpersArray: CustomHelper[] = HelpersArray.filter((helper) => !helper.isInline);\n\n/**\n * Holds a map of { elementType: helper } to make all block helpers accessible by its type more easily.\n */\nconst BlockHelpers: Partial<Record<CustomElementType, CustomHelper>> = {};\n\nBlockHelpersArray.forEach((helper) => {\n    BlockHelpers[helper.elementType] = helper;\n});\n\nexport { BlockHelpers };\n\n/**\n * Holds all available helpers rendering inline elements.\n */\nexport const InlineHelpersArray: CustomHelper[] = HelpersArray.filter((helper) => helper.isInline);\n\n/**\n * Holds a map of { elementType: helper } to make all inline helpers accessible by its type more easily.\n */\nconst InlineHelpers: Partial<Record<CustomElementType, CustomHelper>> = {};\n\nInlineHelpersArray.forEach((helper) => {\n    InlineHelpers[helper.elementType] = helper;\n});\n\nexport { InlineHelpers };\n\n/**\n * Holds all available helpers rendering void elements.\n */\nexport const VoidHelpersArray: CustomHelper[] = HelpersArray.filter((helper) => helper.isVoid);\n\n/**\n * Holds a map of { elementType: helper } to make all inline helpers accessible by its type more easily.\n */\nconst VoidHelpers: Partial<Record<CustomElementType, CustomHelper>> = {};\n\nVoidHelpersArray.forEach((helper) => {\n    VoidHelpers[helper.elementType] = helper;\n});\n\nexport { VoidHelpers };\n", "import React from 'react';\nimport styles from './ToolbarButtonSpacer.module.css';\n\n/**\n * Renders a spacer that can be used to separate button groups in the toolbar.\n *\n * @constructor\n */\nexport const ToolbarButtonSpacer = () => {\n    return (\n        <div className={styles.container}>\n            <div className={styles.spacer}></div>\n        </div>\n    );\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/components/MarkdownEditor/ToolbarButtonSpacer/ToolbarButtonSpacer.module.css\";\n\nexport default {\n  \"container\": \"ToolbarButtonSpacer-module__container_kEBEkG__030\",\n  \"spacer\": \"ToolbarButtonSpacer-module__spacer_kEBEkG__030\"\n};\n      ", "import React, { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { ToolbarButton } from '../ToolbarButton/ToolbarButton';\nimport { Popover } from '../../../shared/components/Popover/Popover';\nimport styles from './HyperlinkToolbarButton.module.css';\nimport { ReactEditor, useSlate } from 'slate-react';\nimport { HyperlinkHelper } from '../Helpers/HyperlinkHelper';\nimport { SlateUtils } from '../Utils/SlateUtils';\nimport { Form } from '../../../shared/components/Form/Form';\nimport { CustomStyle, CustomStyleContext } from '../../../shared/contexts/CustomStyle/Context';\n\n/**\n * Shows a toolbar button for creating or editing an hyperlink.\n *\n * @constructor\n */\nexport const HyperlinkToolbarButton = () => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n    const editor = useSlate();\n    const [showPopover, setShowPopover] = useState<boolean>(false);\n    const [href, setHref] = useState<string>('');\n    const hrefInputRef = useRef<HTMLInputElement>(null);\n\n    /**\n     * Called if the popover is shown to determine the current href value in the selection, if exists.\n     * Also focuses the text field to be able to type without clicking in it.\n     */\n    useEffect(() => {\n        if (!showPopover) return;\n\n        // focus the textfield\n        hrefInputRef.current?.focus();\n\n        // find initial value for href\n        const nearestHyperlink = SlateUtils.nearestElementOfType(editor, 'hyperlink');\n        if (!nearestHyperlink || !nearestHyperlink.href) return setHref('https://niiice.io');\n\n        setHref(nearestHyperlink.href);\n    }, [showPopover, editor]);\n\n    /**\n     * Called if the popover holding the form values should be closed.\n     * Closes the popover.\n     */\n    const onClosePopover = () => {\n        setShowPopover(false);\n\n        ReactEditor.focus(editor);\n    };\n\n    /**\n     * Called if the user clicks the button.\n     * Opens the Popover for the hyperlink form values.\n     */\n    const onClickToolbarButton = () => {\n        setShowPopover(!showPopover);\n    };\n\n    /**\n     * Called if the user submits the data.\n     * Inserts the link having the specified title and href.\n     */\n    const onClickSubmit = () => {\n        if (!HyperlinkHelper.onUpsert) return;\n\n        HyperlinkHelper.onUpsert(editor, { href: href, children: [{ text: href }] });\n        onClosePopover();\n    };\n\n    /**\n     * Returns whether the current selected element is a hyperlink.\n     */\n    const isHyperlink = useMemo(() => {\n        return SlateUtils.isChildOf(editor, 'hyperlink');\n    }, [editor.selection]);\n\n    /**\n     * Called if the user clicks the remove button.\n     * Removes the hyperlink if the current selection is a hyperlink.\n     */\n    const onClickRemove = () => {\n        HyperlinkHelper.toggle(editor);\n        onClosePopover();\n    };\n\n    /**\n     * Called if the user presses the enter button in the popover form.\n     * Submits the form.\n     */\n    const onPressEnter = () => {\n        onClickSubmit();\n    };\n\n    return (\n        <div className={styles.container}>\n            <ToolbarButton onClick={onClickToolbarButton} icon=\"hyperlink\" />\n            {showPopover && (\n                <Popover onClose={onClosePopover} onPressEnter={onPressEnter} align=\"top-right\">\n                    <Form>\n                        <Form.Group>\n                            <Form.Label text={customStyle?.texts?.url || 'Url'} />\n                            <Form.Input\n                                ref={hrefInputRef}\n                                value={href}\n                                onChange={setHref}\n                                className={styles.hrefInput}\n                            />\n                        </Form.Group>\n\n                        <Form.ButtonGroup>\n                            {isHyperlink && (\n                                <Form.Button type=\"danger\" onClick={onClickRemove}>\n                                    {customStyle?.texts?.remove || 'Remove'}\n                                </Form.Button>\n                            )}\n                            <Form.Button type=\"primary\" onClick={onClickSubmit}>\n                                {customStyle?.texts?.insert || 'Insert'}\n                            </Form.Button>\n                        </Form.ButtonGroup>\n                    </Form>\n                </Popover>\n            )}\n        </div>\n    );\n};\n", "import React, { ReactNode, useRef, KeyboardEvent, useContext } from 'react';\nimport styles from './Popover.module.css';\nimport { useOnClickOutside } from 'usehooks-ts';\nimport { CustomStyle, CustomStyleContext } from '../../contexts/CustomStyle/Context';\n\n/**\n * Props for the Popover component.\n */\ninterface PopoverProps {\n    align: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';\n\n    // The content of the popover\n    children: ReactNode;\n\n    // Called if the user clicks outside the popover. Should close the popover.\n    onClose: (e: MouseEvent) => void;\n\n    // Called if the user presses the enter button inside the popup\n    onPressEnter?: () => void;\n}\n\n/**\n * Shows a popover at the current elements position, but overlapping the content.\n * The popover content is given by the props as children.\n *\n * @param props\n * @constructor\n */\nexport const Popover = (props: PopoverProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n    const clickOutsideRef = useRef<HTMLDivElement>(null);\n\n    // Clicking outside the modal should close the modal\n    // @ts-ignore TODO remove if https://github.com/juliencrn/usehooks-ts/issues/663 is fixed\n    useOnClickOutside(clickOutsideRef, props.onClose);\n\n    /**\n     * Called if the user presses some key in the popup.\n     * If the callback for pressing enter is given by the props and the pressed button was the enter button,\n     * the callback will be called.\n     *\n     * @param e\n     */\n    const onKeyDown = (e: KeyboardEvent<HTMLDivElement>) => {\n        if (!props.onPressEnter) return;\n\n        if (e.key === 'Enter') {\n            props.onPressEnter();\n        }\n    };\n\n    return (\n        <div className={`${styles.container} ${customStyle?.popover?.containerClassName || ''}`}>\n            <div\n                className={`${styles.innerContainer} ${props.align} ${\n                    customStyle?.popover?.innerContainerClassName || ''\n                }`}\n                ref={clickOutsideRef}\n                onKeyDown={onKeyDown}\n            >\n                {props.children}\n            </div>\n        </div>\n    );\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/shared/components/Popover/Popover.module.css\";\n\nexport default {\n  \"container\": \"Popover-module__container_dxsL9W__030\",\n  \"innerContainer\": \"Popover-module__innerContainer_dxsL9W__030\"\n};\n      ", "import \"esbuild-css-modules-plugin-ns-css:src/components/MarkdownEditor/HyperlinkToolbarButton/HyperlinkToolbarButton.module.css\";\n\nexport default {\n  \"container\": \"HyperlinkToolbarButton-module__container_KZEcDq__030\",\n  \"hrefInput\": \"HyperlinkToolbarButton-module__hrefInput_KZEcDq__030\"\n};\n      ", "import React, { ReactNode, useContext } from 'react';\nimport styles from './Form.module.css';\nimport { FormGroup } from '../FormGroup/FormGroup';\nimport { FormLabel } from '../FormLabel/FormLabel';\nimport { CustomStyle, CustomStyleContext } from '../../contexts/CustomStyle/Context';\nimport { FormInput } from '../FormInput/FormInput';\nimport { FormError } from '../FormError/FormError';\nimport { FormButtonGroup } from '../FormButtonGroup/FormButtonGroup';\nimport { FormButton } from '../FormButton/FormButton';\n\n/**\n * Props for the Form component.\n */\ninterface FormProps {\n    // The content shown in the form\n    children: ReactNode;\n}\n\n/**\n * Container class for forms.\n * Holds the content provided by the children.\n *\n * @constructor\n */\nexport const Form = (props: FormProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n\n    return (\n        <form className={`${styles.container} ${customStyle?.forms?.containerClassName || ''}`}>{props.children}</form>\n    );\n};\n\nForm.Group = FormGroup;\nForm.Label = FormLabel;\nForm.Input = FormInput;\nForm.Error = FormError;\nForm.ButtonGroup = FormButtonGroup;\nForm.Button = FormButton;\n", "import \"esbuild-css-modules-plugin-ns-css:src/shared/components/Form/Form.module.css\";\n\nexport default {\n  \"container\": \"Form-module__container_R0Llbq__030\"\n};\n      ", "import React, { ReactNode, useContext } from 'react';\nimport styles from './FormGroup.module.css';\nimport { CustomStyle, CustomStyleContext } from '../../contexts/CustomStyle/Context';\n\n/**\n * Props for the FormGroup component.\n */\nexport interface FormGroupProps {\n    // The content shown in the form group\n    children: ReactNode;\n}\n\n/**\n * Container component for form groups holding a label, a field and an error message.\n *\n * @param props\n * @constructor\n */\nexport const FormGroup = (props: FormGroupProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n\n    return <div className={`${styles.container} ${customStyle?.forms?.groupClassName || ''}`}>{props.children}</div>;\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/shared/components/FormGroup/FormGroup.module.css\";\n\nexport default {\n  \"container\": \"FormGroup-module__container_t4ESPW__030\"\n};\n      ", "import React, { useContext } from 'react';\nimport styles from './FormLabel.module.css';\nimport { CustomStyle, CustomStyleContext } from '../../contexts/CustomStyle/Context';\n\n/**\n * Props for the FormLabel component.\n */\nexport interface FormLabelProps {\n    // The text shown in a label\n    text: string;\n}\n\n/**\n * Shows a label for a field in a form group.\n *\n * @param props\n * @constructor\n */\nexport const FormLabel = (props: FormLabelProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n\n    return <label className={`${styles.label} ${customStyle?.forms?.labelClassName}`}>{props.text}</label>;\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/shared/components/FormLabel/FormLabel.module.css\";\n\nexport default {\n  \"label\": \"FormLabel-module__label_jkwkqq__030\"\n};\n      ", "import React, { ChangeEvent, Ref, useContext } from 'react';\nimport styles from './FormInput.module.css';\nimport { CustomStyle, CustomStyleContext } from '../../contexts/CustomStyle/Context';\n\n/**\n * Props for the Input component.\n */\nexport interface FormInputProps {\n    // The current input content\n    value: string;\n\n    // Called if the content of the input changed\n    onChange: (value: string) => void;\n\n    // Optional ref to the input\n    ref?: Ref<HTMLInputElement>;\n\n    // Optional class name that is added to the input\n    className?: string;\n}\n\n/**\n * Default one line Text input for forms.\n *\n * @param props\n * @constructor\n */\nexport const FormInput = (props: FormInputProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n\n    /**\n     * Called if the content of the input changed.\n     * Calls the callback given by the props.\n     *\n     * @param event\n     */\n    const onChange = (event: ChangeEvent<HTMLInputElement>) => {\n        props.onChange(event.target.value);\n    };\n\n    return (\n        <input\n            ref={props.ref}\n            className={`${styles.input} ${props.className || undefined} ${customStyle?.forms?.inputClassName || ''}`}\n            value={props.value}\n            onChange={onChange}\n        />\n    );\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/shared/components/FormInput/FormInput.module.css\";\n\nexport default {\n  \"input\": \"FormInput-module__input_x5oyYq__030\"\n};\n      ", "import React, { useContext } from 'react';\nimport styles from './FormError.module.css';\nimport { CustomStyle, CustomStyleContext } from '../../contexts/CustomStyle/Context';\n\n/**\n * Props for the FormError component.\n */\nexport interface FormErrorProps {\n    text: string;\n}\n\n/**\n * Shosws an error message for a field in a form group.\n *\n * @param props\n * @constructor\n */\nexport const FormError = (props: FormErrorProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n\n    return <span className={`${styles.error} ${customStyle?.forms?.errorClassName || ''}`}>{props.text}</span>;\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/shared/components/FormError/FormError.module.css\";\n\nexport default {\n  \"error\": \"FormError-module__error_TZXMUq__030\"\n};\n      ", "import React, { ReactNode, useContext } from 'react';\nimport styles from './FormButtonGroup.module.css';\nimport { CustomStyle, CustomStyleContext } from '../../contexts/CustomStyle/Context';\n\n/**\n * Props for the FormButtonGroup component.\n */\nexport interface FormButtonGroupProps {\n    // The content of the button group\n    children: ReactNode;\n}\n\n/**\n * Container component holding form buttons like the submit button.\n *\n * @param props\n * @constructor\n */\nexport const FormButtonGroup = (props: FormButtonGroupProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n\n    return (\n        <div className={`${styles.container} ${customStyle?.forms?.buttonsContainerClassName || ''}`}>\n            {props.children}\n        </div>\n    );\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/shared/components/FormButtonGroup/FormButtonGroup.module.css\";\n\nexport default {\n  \"container\": \"FormButtonGroup-module__container_4Hygba__030\"\n};\n      ", "import React, { ReactNode, useContext, MouseEvent } from 'react';\nimport styles from './FormButton.module.css';\nimport { CustomStyle, CustomStyleContext } from '../../contexts/CustomStyle/Context';\n\n/**\n * Props for the Button component.\n */\nexport interface FormButtonProps {\n    // The type of the button, defining its design\n    type: 'primary' | 'secondary' | 'danger';\n\n    // Called if the user clicks the button\n    onClick: () => void;\n\n    // The content inside the button\n    children: ReactNode;\n}\n\nexport const FormButton = (props: FormButtonProps) => {\n    const customStyles = useContext<CustomStyle | undefined>(CustomStyleContext);\n\n    /**\n     * Called if the mouse button was pressed in the button.\n     * Prevents the event to prevent the editor from loosing focus on clicking.\n     * This is needed because if the onBlur event in the editor is used to get the current value,\n     * it would be triggered on pressing the button.\n     *\n     * @param event\n     */\n    const onMouseDown = (event: MouseEvent<HTMLButtonElement>) => {\n        event.preventDefault();\n    };\n\n    return (\n        <button\n            className={`${styles.button} ${customStyles?.forms?.buttonClassName} ${props.type}`}\n            onClick={props.onClick}\n            onMouseDown={onMouseDown}\n        >\n            {props.children}\n        </button>\n    );\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/shared/components/FormButton/FormButton.module.css\";\n\nexport default {\n  \"button\": \"FormButton-module__button_C8cIaW__030\"\n};\n      ", "import { ReactEditor, useSlate } from 'slate-react';\nimport React, { useContext, useEffect, useRef, useState } from 'react';\nimport { SlateUtils } from '../Utils/SlateUtils';\nimport styles from './ImageToolbarButton.module.css';\nimport { ToolbarButton } from '../ToolbarButton/ToolbarButton';\nimport { Popover } from '../../../shared/components/Popover/Popover';\nimport { ImageHelper } from '../Helpers/ImageHelper';\nimport { Form } from '../../../shared/components/Form/Form';\nimport { CustomStyle, CustomStyleContext } from '../../../shared/contexts/CustomStyle/Context';\n\n/**\n * Props for the ImageToolbarButton component.\n */\ninterface ImageToolbarButtonProps {\n    // Called if the user wants to upload some file, should open the upload modal. The accept parameter are\n    // comma separated mime types. If not given, everything will be accepted.\n    onUploadRequest?: (accept?: string) => void;\n}\n\n/**\n * Shows a toolbar button for creating or editing an image.\n *\n * @constructor\n */\nexport const ImageToolbarButton = (props: ImageToolbarButtonProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n    const editor = useSlate();\n    const [showPopover, setShowPopover] = useState<boolean>(false);\n    const [src, setSrc] = useState<string>('');\n    const srcInputRef = useRef<HTMLInputElement>(null);\n\n    /**\n     * Called if the popover is shown to determine the current src value in the selection, if exists.\n     * Also focuses the text field to be able to type without clicking in it.\n     */\n    useEffect(() => {\n        if (!showPopover) return;\n\n        // focus the textfield\n        srcInputRef.current?.focus();\n\n        // find initial value for href\n        const nearestImage = SlateUtils.nearestElementOfType(editor, 'image');\n        if (!nearestImage || !nearestImage.src)\n            return setSrc('https://niiice.io/wp-content/uploads/2020/04/niiice-Logo_dark.png');\n\n        setSrc(nearestImage.src);\n    }, [showPopover, editor]);\n\n    /**\n     * Called if the popover holding the form values should be closed.\n     * Closes the popover.\n     */\n    const onClosePopover = () => {\n        setShowPopover(false);\n\n        ReactEditor.focus(editor);\n    };\n\n    /**\n     * Called if the user clicks the button.\n     * Opens the Popover for the hyperlink form values.\n     */\n    const onClickToolbarButton = () => {\n        setShowPopover(!showPopover);\n    };\n\n    /**\n     * Called if the user submits the data.\n     * Inserts the link having the specified title and href.\n     */\n    const onClickSubmit = () => {\n        if (!ImageHelper.onUpsert) return;\n\n        ImageHelper.onUpsert(editor, { src: src });\n        onClosePopover();\n    };\n\n    /**\n     * Called if the user presses the enter button in the popover form.\n     * Submits the form.\n     */\n    const onPressEnter = () => {\n        onClickSubmit();\n    };\n\n    /**\n     * Called if the user clicks the upload button.\n     * Closes the popup and opens the upload modal.\n     */\n    const onClickUpload = () => {\n        if (!props.onUploadRequest) return;\n\n        onClosePopover();\n        props.onUploadRequest('image/*');\n    };\n\n    return (\n        <div className={styles.container}>\n            <ToolbarButton onClick={onClickToolbarButton} icon=\"image\" />\n            {showPopover && (\n                <Popover onClose={onClosePopover} onPressEnter={onPressEnter} align=\"top-right\">\n                    <Form>\n                        <Form.Group>\n                            <Form.Label text={customStyle?.texts?.url || 'Url'} />\n                            <Form.Input ref={srcInputRef} value={src} onChange={setSrc} className={styles.srcInput} />\n                        </Form.Group>\n\n                        <Form.ButtonGroup>\n                            {props.onUploadRequest && (\n                                <Form.Button type={'secondary'} onClick={onClickUpload}>\n                                    {customStyle?.texts?.upload || 'Upload'}\n                                </Form.Button>\n                            )}\n\n                            <Form.Button type=\"primary\" onClick={onClickSubmit}>\n                                {customStyle?.texts?.insert || 'Insert'}\n                            </Form.Button>\n                        </Form.ButtonGroup>\n                    </Form>\n                </Popover>\n            )}\n        </div>\n    );\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/components/MarkdownEditor/ImageToolbarButton/ImageToolbarButton.module.css\";\n\nexport default {\n  \"container\": \"ImageToolbarButton-module__container_N6H06G__030\",\n  \"srcInput\": \"ImageToolbarButton-module__srcInput_N6H06G__030\"\n};\n      ", "import \"esbuild-css-modules-plugin-ns-css:src/components/MarkdownEditor/MarkdownEditor.module.css\";\n\nexport default {\n  \"container\": \"MarkdownEditor-module__container_mfJZzW__030\",\n  \"editor\": \"MarkdownEditor-module__editor_mfJZzW__030\"\n};\n      ", "import \"esbuild-css-modules-plugin-ns-css:src/shared/styles/elements.module.css\";\n\nexport default {\n  \"container\": \"elements-module__container_bH2TYq__030\"\n};\n      ", "import React, { ChangeEvent, useContext, useEffect, useState } from 'react';\nimport {\n    AbstractUploader,\n    UploaderErrorCallback,\n    UploaderFinishCallback,\n    UploaderProgressCallback\n} from '../Upload/Uploader/AbstractUploader';\nimport styles from './UploadModal.module.css';\nimport { Modal } from '../../../shared/components/Modal/Modal';\nimport { Form } from '../../../shared/components/Form/Form';\nimport { FormGroup } from '../../../shared/components/FormGroup/FormGroup';\nimport { CustomStyle, CustomStyleContext } from '../../../shared/contexts/CustomStyle/Context';\n\n/**\n * Props for the UploadModal component.\n */\ninterface UploadModalProps {\n    // The uploader that is used to uplad the files\n    uploader: AbstractUploader;\n\n    // Called if the upload of a file to the specified url was finished.\n    // The metadata should be used to be appended to the dom. This can be used to save additional data needed\n    // for further operations on the file.\n    onUploadFinish: UploaderFinishCallback;\n\n    // If given, the selected file types will be validated before upload. Can be a comma seperated string of\n    // valid mime types, including *, eg. \"image/*, application/csv\"\n    acceptedFileTypes?: string;\n\n    // If given, the selected file sizes (in bytes) will be validated before upload\n    maxFileSize?: number;\n\n    // Called if the modal should be closed\n    onClose: () => void;\n}\n\n/**\n * Shows a modal that provides a form to upload a file.\n *\n * @param props\n * @constructor\n */\nexport const UploadModal = (props: UploadModalProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n    const [errorMessage, setErrorMessage] = useState<string | null>(null);\n    const [uploadProgress, setUploadProgress] = useState<number | null>(null);\n\n    /**\n     * Called if the current upload failes.\n     * Shows the error.\n     *\n     * @param error\n     */\n    const onUploadError: UploaderErrorCallback = (error: Error) => {\n        setErrorMessage(error.message);\n    };\n\n    /**\n     * Called on progress for the current upload.\n     * Shows the upload progress.\n     *\n     * @param progress\n     */\n    const onUploadProgress: UploaderProgressCallback = (progress: number) => {\n        setUploadProgress(progress);\n    };\n\n    /**\n     * Called if the upload was finished.\n     * Calls the onFinish callback given by the props.\n     *\n     * @param url\n     * @param originalFile\n     * @param metaData\n     */\n    const onUploadFinish: UploaderFinishCallback = (\n        url: string,\n        originalFile: File,\n        metaData: Record<string, string>\n    ) => {\n        props.onUploadFinish(url, originalFile, metaData);\n    };\n\n    /**\n     * Called if the uploader in the props changes.\n     * Sets the view callbacks in the uploader to be able to track upload process, upload finish and upload errors.\n     */\n    useEffect(() => {\n        props.uploader.setOnProgressViewCallback(onUploadProgress);\n        props.uploader.setOnErrorViewCallback(onUploadError);\n        props.uploader.setOnFinishViewCallback(onUploadFinish);\n    }, [props.uploader]);\n\n    /**\n     * Called if the user selected some file.\n     * Uploads the file using the uploader given by the props.\n     *\n     * @param event\n     */\n    const onFileSelect = (event: ChangeEvent<HTMLInputElement>) => {\n        // First hide errors, in case of retry\n        setErrorMessage(null);\n\n        // get selected files\n        const files = event.currentTarget.files;\n        if (!files) return;\n\n        // Convert to array because FileList is not really a list.\n        // This is because javascript is just HUEHUEHUEHUEHUEHUEHUEHUEHUEHUEHUE\n        const selectedFiles = Array.from(files);\n\n        // check file types\n        if (props.acceptedFileTypes) {\n            for (const file of selectedFiles) {\n                if (!fileTypeMatches(file.type, props.acceptedFileTypes)) {\n                    return setErrorMessage(customStyle?.texts?.invalidFileTypeError || 'Invalid file type.');\n                }\n            }\n        }\n\n        // check file size\n        if (props.maxFileSize) {\n            for (const file of selectedFiles) {\n                if (file.size > props.maxFileSize) {\n                    return setErrorMessage(customStyle?.texts?.maxFileSizeError || 'File too large.');\n                }\n            }\n        }\n\n        // Start uploading each file and add it to the current files\n        setUploadProgress(0);\n\n        for (const selectedFile of selectedFiles) {\n            props.uploader.startUpload(selectedFile).then();\n        }\n    };\n\n    return (\n        <Modal title={customStyle?.texts?.uploadModalHeaderTitle || 'Upload file'} onClose={props.onClose}>\n            <Form>\n                <FormGroup>\n                    <input\n                        className={styles.fileInput}\n                        type=\"file\"\n                        onChange={onFileSelect}\n                        disabled={uploadProgress !== null}\n                    />\n\n                    {errorMessage && <Form.Error text={errorMessage} />}\n                </FormGroup>\n            </Form>\n\n            {uploadProgress !== null && (\n                <progress className={styles.progressBar} max={100.0} value={uploadProgress * 100} />\n            )}\n        </Modal>\n    );\n};\n\n/**\n * Returns whether the specified fileType matches any of the specified expected file types.\n * expectedFileTypes is expected to be a comma separated value of valid file types.\n * Stars (*) are allowed to define any valid \"subtype\", like image/*.\n *\n * @param fileType\n * @param expectedFileTypes\n */\nconst fileTypeMatches = (fileType: string, expectedFileTypes: string): boolean => {\n    // remove all whitespaces\n    expectedFileTypes = expectedFileTypes.replace(/\\s/g, '');\n\n    // convert to array\n    const expectedFileTypesArray = expectedFileTypes.split(',');\n\n    // check the types\n    return expectedFileTypesArray.some((expectedFileType: string) => {\n        if (expectedFileType.endsWith('/*')) {\n            const mainType = expectedFileType.split('/')[0];\n            return fileType.startsWith(mainType);\n        } else {\n            return expectedFileType === fileType;\n        }\n    });\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/components/MarkdownEditor/UploadModal/UploadModal.module.css\";\n\nexport default {\n  \"fileInput\": \"UploadModal-module__fileInput_uGKa2W__030\",\n  \"progressBar\": \"UploadModal-module__progressBar_uGKa2W__030\"\n};\n      ", "import React, { ReactNode, useContext, useRef } from 'react';\nimport { IoCloseOutline } from 'react-icons/io5';\nimport styles from './Modal.module.css';\nimport { useOnClickOutside } from 'usehooks-ts';\nimport { CustomStyle, CustomStyleContext } from '../../contexts/CustomStyle/Context';\n\n/**\n * Props for the Modal component.\n */\ninterface ModalProps {\n    // The title shown in the header\n    title: string;\n\n    // Called if the user clicks outside the modal or the close button\n    onClose: () => void;\n\n    // The body content of the modal\n    children: ReactNode;\n}\n\n/**\n * Shows a modal having the children given by the props as content.\n * The modal also has a header with a title, that is given by the props.\n * The design of the modal is customizable via the className props.\n *\n * @param props\n * @constructor\n */\nexport const Modal = (props: ModalProps) => {\n    const customStyle = useContext<CustomStyle | undefined>(CustomStyleContext);\n    const clickOutsideRef = useRef<HTMLDivElement>(null);\n\n    // Clicking outside the modal should close the modal\n    // @ts-ignore TODO remove if https://github.com/juliencrn/usehooks-ts/issues/663 is fixed\n    useOnClickOutside(clickOutsideRef, props.onClose);\n\n    return (\n        <div className={`${styles.container} ${customStyle?.modal?.containerClassName || ''}`}>\n            <div\n                className={`${styles.innerContainer} ${customStyle?.modal?.innerContainerClassName || ''}`}\n                ref={clickOutsideRef}\n            >\n                <div className={`${styles.headerContainer} ${customStyle?.modal?.headerContainerClassName || ''}`}>\n                    <span className={styles.header}>{props.title}</span>\n                    <button className={styles.closeButton} onClick={props.onClose}>\n                        <IoCloseOutline size=\"1.5rem\" />\n                    </button>\n                </div>\n                <div className={`${styles.bodyContainer} ${customStyle?.modal?.bodyContainerClassName || ''}`}>\n                    {props.children}\n                </div>\n            </div>\n        </div>\n    );\n};\n", "import \"esbuild-css-modules-plugin-ns-css:src/shared/components/Modal/Modal.module.css\";\n\nexport default {\n  \"bodyContainer\": \"Modal-module__bodyContainer_QZ8FHq__030\",\n  \"closeButton\": \"Modal-module__closeButton_QZ8FHq__030\",\n  \"container\": \"Modal-module__container_QZ8FHq__030\",\n  \"header\": \"Modal-module__header_QZ8FHq__030\",\n  \"headerContainer\": \"Modal-module__headerContainer_QZ8FHq__030\",\n  \"innerContainer\": \"Modal-module__innerContainer_QZ8FHq__030\"\n};\n      ", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the Heading1Element component.\n */\ntype ImageElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a heading of size 1.\n *\n * @param props\n * @constructor\n */\nexport const ImageElement = (props: ImageElementProps) => {\n    return (\n        <span contentEditable={false} {...props.attributes}>\n            <img src={props.element.src} alt={props.element.altText || 'Image'} />\n            {props.children}\n        </span>\n    );\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the Heading1Element component.\n */\ntype HyperlinkElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a heading of size 1.\n *\n * @param props\n * @constructor\n */\nexport const HyperlinkElement = (props: HyperlinkElementProps) => {\n    return (\n        <a href={props.element.href} {...props.attributes}>\n            {props.children}\n        </a>\n    );\n};\n", "import React, { ReactNode } from 'react';\nimport { CustomStyle, CustomStyleContext } from './Context';\n\n/**\n * Props for the CustomStyleContextProvider.\n */\ninterface CustomStyleContextProviderProps {\n    // The value of the provider\n    value: CustomStyle | undefined;\n\n    // The children that can access the context value\n    children: ReactNode;\n}\n\n/**\n * Context provider for the CustomStyle value.\n */\nexport const CustomStyleContextProvider = (props: CustomStyleContextProviderProps) => {\n    return <CustomStyleContext.Provider value={props.value}>{props.children}</CustomStyleContext.Provider>;\n};\n", "import React from 'react';\nimport { RenderElementProps } from 'slate-react';\n\n/**\n * Props for the UnorderedListElement component.\n */\ntype OrderedListItemElementProps = RenderElementProps;\n\n/**\n * A Custom element for Slate for rendering a list item in an unordered or ordered list.\n *\n * @param props\n * @constructor\n */\nexport const OrderedListItemElement = (props: OrderedListItemElementProps) => {\n    return <li {...props.attributes}>{props.children}</li>;\n};\n", "import React, { useMemo } from 'react';\nimport { EditorValue } from '../MarkdownEditor/MarkdownEditor';\nimport { toMarkdown } from '../../shared/serializers/EditorValueMarkdownSerializer';\nimport ReactMarkdown from 'react-markdown';\nimport remarkGfm from 'remark-gfm';\nimport remarkBreaks from 'remark-breaks';\nimport elementStyles from '../../shared/styles/elements.module.css';\n\n/**\n * Props for the Editor component.\n */\nexport interface MarkdownViewProps {\n    // The markdown value as string or the editor value that is serialized to markdown\n    value: EditorValue | string;\n\n    // Optional class name that is appended to the root container\n    className?: string;\n}\n\n/**\n * A view to show the markdown given by the props, having the same style like the ReMaWy Editor.\n *\n * @param props\n * @constructor\n */\nexport const MarkdownView = (props: MarkdownViewProps) => {\n    const markdown = useMemo(() => {\n        if (typeof props.value === 'string') return props.value;\n\n        return toMarkdown(props.value);\n    }, [props.value]);\n\n    return (\n        <div className={`${elementStyles.container} ${props.className || ''}`}>\n            <ReactMarkdown\n                remarkPlugins={[remarkGfm, remarkBreaks]}\n            >\n                {markdown}\n            </ReactMarkdown>\n        </div>\n    );\n};\n", "import { EditorValue } from '../../components';\nimport { Descendant } from 'slate';\nimport { CustomElement, CustomElementType } from '../../components/MarkdownEditor/Types/CustomElement';\nimport { SlateUtils } from '../../components/MarkdownEditor/Utils/SlateUtils';\nimport { CustomText } from '../../components/MarkdownEditor/Types/CustomText';\n\n/**\n * Returns the number of elementTypes having the specified targetType in the elementTypes array.\n *\n * @param elementTypes\n * @param targetType\n */\nconst elementTypesCount = (elementTypes: CustomElementType[], targetType: CustomElementType) => {\n    return elementTypes.filter((elementType) => elementType === targetType).length;\n};\n\n/**\n * Returns the number of indents as text.\n *\n * @param num\n */\nconst getIndentsText = (num: number): string => {\n    return Array(num * 4).join(' ');\n};\n\n/**\n * value is the element to render and parents is a list of element types this element is located in.\n */\ntype CustomElementSerializerFunc = (value: CustomElement, parents: CustomElementType[]) => string;\n\n/**\n * Maps the elements to its serializer functions.\n */\nconst serializers: Record<CustomElementType, CustomElementSerializerFunc> = {\n    blockquote: (value: CustomElement, parents: CustomElementType[]) => {\n        return `> ${serializeChildren(value.children, [...parents, 'blockquote'])}\\n`;\n    },\n    code: (value: CustomElement, parents: CustomElementType[]) => {\n        return `\\`\\`\\`\\n${serializeChildren(value.children, [...parents, 'code'])}\\n\\`\\`\\`\\n`;\n    },\n    'heading-1': (value: CustomElement, parents: CustomElementType[]) => {\n        return `# ${serializeChildren(value.children, [...parents, 'heading-1'])}\\n`;\n    },\n    'heading-2': (value: CustomElement, parents: CustomElementType[]) => {\n        return `## ${serializeChildren(value.children, [...parents, 'heading-2'])}\\n`;\n    },\n    'heading-3': (value: CustomElement, parents: CustomElementType[]) => {\n        return `### ${serializeChildren(value.children, [...parents, 'heading-3'])}\\n`;\n    },\n    'heading-4': (value: CustomElement, parents: CustomElementType[]) => {\n        return `#### ${serializeChildren(value.children, [...parents, 'heading-4'])}\\n`;\n    },\n    'heading-5': (value: CustomElement, parents: CustomElementType[]) => {\n        return `##### ${serializeChildren(value.children, [...parents, 'heading-5'])}\\n`;\n    },\n    'heading-6': (value: CustomElement, parents: CustomElementType[]) => {\n        return `###### ${serializeChildren(value.children, [...parents, 'heading-6'])}\\n`;\n    },\n    hyperlink: (value: CustomElement, parents: CustomElementType[]) => {\n        return `[${serializeChildren(value.children, [...parents, 'hyperlink'])}](${value.href || ''})`;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    image: (value: CustomElement, parents: CustomElementType[]) => {\n        return `![${value.altText || ''}](${value.src || ''})`;\n    },\n    'ordered-list': (value: CustomElement, parents: CustomElementType[]) => {\n        return serializeChildren(value.children, [...parents, 'ordered-list']);\n    },\n    'ordered-list-item': (value: CustomElement, parents: CustomElementType[]) => {\n        const listsCount = elementTypesCount(parents, 'ordered-list');\n\n        let result = getIndentsText(listsCount - 1);\n        result = `${result}1. ${serializeChildren(value.children, [...parents, 'ordered-list-item'])}\\n`;\n\n        return result;\n    },\n    paragraph: (value: CustomElement, parents: CustomElementType[]) => {\n        return `\\n${serializeChildren(value.children, [...parents, 'paragraph'])}\\n`;\n    },\n    'unordered-list': (value: CustomElement, parents: CustomElementType[]) => {\n        return serializeChildren(value.children, [...parents, 'unordered-list']);\n    },\n    'unordered-list-item': (value: CustomElement, parents: CustomElementType[]) => {\n        const listsCount = elementTypesCount(parents, 'unordered-list');\n\n        let result = getIndentsText(listsCount - 1);\n        result = `${result}* ${serializeChildren(value.children, [...parents, 'unordered-list-item'])}\\n`;\n\n        return result;\n    }\n};\n\n/**\n * Returns the markdown of the specified value that is expected to be a leaf.\n */\nconst serializeLeaf = (value: CustomText): string => {\n    if (!value.text) return '';\n\n    let text = value.text;\n    if (value.bold) {\n        text = `**${text}**`;\n    }\n\n    if (value.italic) {\n        text = `*${text}*`;\n    }\n\n    return text;\n};\n\n/**\n * Returns the markdown of the custom element having the specified parents.\n *\n * @param value\n * @param parents\n */\nconst serializeElement = (value: CustomElement, parents: CustomElementType[]): string => {\n    const func: CustomElementSerializerFunc = serializers[value.type];\n    if (!func) return '';\n\n    return func(value, parents);\n};\n\n/**\n * Serializes the specified element or leaf to markdown.\n * Parents are all the parents element types the element is located in from the rot to the element itself.\n *\n * @param element\n * @param parents\n */\nconst serializeElementOrLeaf = (element: CustomElement | CustomText, parents: CustomElementType[]): string => {\n    if (SlateUtils.isLeaf(element)) {\n        return serializeLeaf(element as CustomText);\n    }\n\n    const customElement: CustomElement = element as CustomElement;\n    if (!customElement['type']) return '';\n\n    return serializeElement(customElement, parents);\n};\n\n/**\n * Serializes the specified children to markdown. If joinValue is given, the children will be connected\n * using this value.\n * Parents are the element types all the parents from the root to the element that contains the children.\n *\n * @param children\n * @param parents\n * @param joinValue\n */\nconst serializeChildren = (\n    children: Descendant[] | undefined,\n    parents: CustomElementType[],\n    joinValue = ''\n): string => {\n    if (!children) return '';\n\n    return children?.map((child) => serializeElementOrLeaf(child, parents)).join(joinValue);\n};\n\n/**\n * Returns the markdown serialized from the specified editorValue.\n *\n * @param editorValue\n */\nexport const toMarkdown = (editorValue: EditorValue): string => {\n    const result = serializeChildren(editorValue, []);\n    return result;\n};\n", "/**\n * Type for a callback indicating a progress.\n * The progress number must be between 0 and 1 and indicate the percentage of upload progress.\n */\nexport type UploaderProgressCallback = (progress: number) => void;\n\n/**\n * Type for a callback indicating some finished upload.\n * The url is the url to the file. The metaData holds information that can be useful for further operations\n * on the asset, like its deletion. It will be hold in the node props and will be used on serialization and deserialization.\n */\nexport type UploaderFinishCallback = (url: string, originalFile: File, metaData: Record<string, string>) => void;\n\n/**\n * Type for a callback indicating that some error occurred during upload.\n */\nexport type UploaderErrorCallback = (error: Error) => void;\n\n/**\n * Abstract class of an Uploader to upload files that can be used\n * as images or other linked assets in the editor. The startUpload method must be implemented.\n * This method should upload the file asynchronous.\n * The upload progress can be indicated by calling the onProgress method of this class.\n * If the upload finished, the onFinish method of this class must be called.\n */\nexport abstract class AbstractUploader {\n    /**\n     * Starts the upload of the specified file.\n     * This is expected to be done asynchronous.\n     *\n     * @param file\n     */\n    public abstract startUpload(file: File): Promise<void>;\n\n    /**\n     * Should be called oj upload progress.\n     * The progress is expected to be a number between 0 and 1, indicating the percentage\n     * of upload progress.\n     *\n     * @param progress\n     * @protected\n     */\n    protected onProgress(progress: number) {\n        if (!this.onProgressViewCallback) return;\n\n        this.onProgressViewCallback(progress);\n    }\n\n    /**\n     * Should be called if the upload was finished.\n     * The url must be the url to the uploaded file.\n     * The originalFile is the file the user selected to upload.\n     * The provided metadata are information about the file that are needed to do further\n     * operations on it, like its deletion. This information is kept in the node settings\n     * and will be serialized and deserialized.\n     *\n     * @param url\n     * @param originalFile\n     * @param metaData\n     * @protected\n     */\n    protected onFinish(url: string, originalFile: File, metaData: Record<string, string> = {}) {\n        if (!this.onFinishViewCallback) return;\n\n        this.onFinishViewCallback(url, originalFile, metaData);\n    }\n\n    /**\n     * Should be called if some error occurs during upload.\n     *\n     * @param error\n     * @protected\n     */\n    protected onError(error: Error) {\n        if (!this.onErrorViewCallback) return;\n\n        this.onErrorViewCallback(error);\n    }\n\n    /**\n     * This is the callback that is called outside of the uploader to indicate the upload progress.\n     * This callback should be set by the view that renders the progress by calling the setOnProgressViewCallback method.\n     * This method should only be used by this package. To indicate the upload process in the uploader itself, call the onProgress method.\n     *\n     * @private\n     */\n    private onProgressViewCallback?: UploaderProgressCallback;\n\n    /**\n     * Sets the callback that is called if some upload progress occures.\n     * This should only be called by the view that uses the uploader.\n     */\n    public setOnProgressViewCallback(callback: UploaderProgressCallback) {\n        this.onProgressViewCallback = callback;\n    }\n\n    /**\n     * This is the callback that is called outside of the uploader to indicate the upload finished.\n     * This callback should be set by the view that renders the upload by calling the setOnFinishViewCallback method.\n     * This method should only be used by this package. To indicate the upload finished in the uploader itself, use the onFinish callback.\n     *\n     * @private\n     */\n    private onFinishViewCallback?: UploaderFinishCallback;\n\n    /**\n     * Sets the callback that is called if some upload finished.\n     * This should only be called by the view that uses the uploader.\n     */\n    public setOnFinishViewCallback(callback: UploaderFinishCallback) {\n        this.onFinishViewCallback = callback;\n    }\n\n    /**\n     * This is the callback that is called outside of the upload to indicate that some error occured during upload.\n     * This callback should be set by the view that renders the upload by calling the setOnErrorViewCallback method.\n     * This method should only be used by this package. To indicate that some error occured during upload in the uploader itself,\n     * use the onError callback.\n     *\n     * @private\n     */\n    private onErrorViewCallback?: UploaderErrorCallback;\n\n    public setOnErrorViewCallback(callback: UploaderErrorCallback) {\n        this.onErrorViewCallback = callback;\n    }\n}\n"],
  "mappings": "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",
  "names": ["React", "useCallback", "useState", "useRef", "useMemo", "createEditor", "Slate", "Editable", "withReact", "ReactEditor", "React", "CodeElement", "props", "React", "ParagraphElement", "props", "React", "BlockquoteElement", "props", "React", "Heading1Element", "props", "React", "Heading2Element", "props", "React", "Heading3Element", "props", "React", "Heading4Element", "props", "React", "Heading5Element", "props", "React", "Heading6Element", "props", "React", "OrderedListElement", "props", "React", "UnorderedListElement", "props", "React", "UnorderedListItemElement", "props", "Editor", "Node", "Point", "Transforms", "Text", "changeCurrentNodeType", "editor", "elementType", "props", "removeInlineNode", "path", "currentElementPath", "currentElement", "currentPath", "currentElementType", "element", "nearestElementOfType", "createNewNodeOfCurrentType", "createNewNode", "type", "options", "targetPath", "wrapNode", "unwrapNode", "unwrapLeaf", "isCursor", "isSelection", "currentBlockStart", "block", "n", "currentBlockEnd", "textSinceBlockStart", "start", "range", "textToBlockEnd", "end", "lastPosOf", "searchText", "blockText", "currentBlockText", "lastIndex", "cursorIsBehind", "setCurrentBlockText", "text", "deleteFromLeft", "numChars", "deleteFromRight", "i", "deleteAt", "isChildOfAny", "elementTypes", "isChildOf", "currentBlock", "nodeEntry", "isElement", "currentBlockPath", "nearestBlockPath", "currentBlockType", "parentBlock", "parentBlockType", "currentLeaf", "isLeaf", "node", "leaf", "isAtRoot", "pos", "isRoot", "isEmpty", "createRootParagraph", "liftToRoot", "createNewline", "SlateUtils", "setLeafFormat", "formatOptions", "changeNearestNodeProps", "React", "CustomLeaf", "props", "resultNode", "Editor", "isBoldActive", "editor", "Editor", "isItalicActive", "setBold", "range", "SlateUtils", "unsetBold", "setItalic", "unsetItalic", "toggleBold", "toggleItalic", "handleBoldAndItalic", "event", "lastPos", "CustomLeafHelper", "React", "useContext", "Toolbar_default", "React", "useMemo", "useContext", "ToolbarButton_default", "FaBold", "FaItalic", "FaListOl", "FaList", "FaQuoteLeft", "FaCode", "FaUpload", "FaLink", "FaImage", "createContext", "CustomStyleContext", "ToolbarButton", "props", "customStyle", "useContext", "CustomStyleContext", "icon", "useMemo", "React", "FaBold", "FaItalic", "FaListOl", "FaList", "FaQuoteLeft", "FaCode", "FaUpload", "FaLink", "FaImage", "event", "ToolbarButton_default", "Editor", "defaultIsActive", "editor", "elementType", "match", "Editor", "n", "defaultToggle", "SlateUtils", "toggleAtRoot", "toggleInlineNode", "props", "defaultChildren", "defaultProps", "toggleWithListAllowed", "isActive", "isInOrderedList", "isInUnorderedList", "isInList", "onEnterWithShiftLinebreak", "event", "onEnterWithListAndNewlineAllowed", "deactivateListItem", "listType", "toggleListItem", "options", "listItemType", "onTabListItem", "parentBlock", "onEnterListItem", "HelperUtils", "active", "editor", "HelperUtils", "toggle", "UnorderedListHelper", "active", "editor", "HelperUtils", "toggle", "OrderedListHelper", "active", "editor", "HelperUtils", "toggle", "onEnter", "event", "BlockquoteHelper", "active", "editor", "HelperUtils", "toggle", "onEnter", "event", "CodeHelper", "active", "editor", "HelperUtils", "toggle", "onEnter", "event", "SlateUtils", "Heading1Helper", "active", "editor", "HelperUtils", "toggle", "onEnter", "event", "SlateUtils", "Heading2Helper", "active", "editor", "HelperUtils", "toggle", "onEnter", "event", "SlateUtils", "Heading3Helper", "active", "editor", "HelperUtils", "toggle", "onEnter", "event", "SlateUtils", "Heading4Helper", "active", "editor", "HelperUtils", "toggle", "onEnter", "event", "SlateUtils", "Heading5Helper", "active", "editor", "HelperUtils", "toggle", "onEnter", "event", "SlateUtils", "Heading6Helper", "active", "editor", "HelperUtils", "toggle", "options", "onTab", "event", "onEnter", "UnorderedListItemHelper", "active", "editor", "HelperUtils", "toggle", "SlateUtils", "onEnter", "event", "ParagraphHelper", "active", "editor", "HelperUtils", "toggle", "options", "props", "linkText", "href", "SlateUtils", "onUpsert", "HyperlinkHelper", "active", "editor", "HelperUtils", "toggle", "options", "props", "altText", "src", "SlateUtils", "onUpsert", "currentElement", "ImageHelper", "active", "editor", "HelperUtils", "toggle", "options", "onTab", "event", "onEnter", "OrderedListItemHelper", "HelpersArray", "BlockquoteHelper", "CodeHelper", "Heading1Helper", "Heading2Helper", "Heading3Helper", "Heading4Helper", "Heading5Helper", "Heading6Helper", "ImageHelper", "HyperlinkHelper", "OrderedListHelper", "OrderedListItemHelper", "ParagraphHelper", "UnorderedListHelper", "UnorderedListItemHelper", "Helpers", "helper", "BlockHelpersArray", "HelpersArray", "helper", "BlockHelpers", "InlineHelpersArray", "HelpersArray", "helper", "InlineHelpers", "VoidHelpersArray", "HelpersArray", "helper", "VoidHelpers", "React", "ToolbarButtonSpacer_default", "ToolbarButtonSpacer", "React", "ToolbarButtonSpacer_default", "useSlate", "React", "useContext", "useEffect", "useMemo", "useRef", "useState", "React", "useRef", "useContext", "Popover_default", "useOnClickOutside", "Popover", "props", "customStyle", "useContext", "CustomStyleContext", "clickOutsideRef", "useRef", "useOnClickOutside", "onKeyDown", "e", "React", "Popover_default", "HyperlinkToolbarButton_default", "ReactEditor", "useSlate", "React", "useContext", "Form_default", "React", "useContext", "FormGroup_default", "FormGroup", "props", "customStyle", "useContext", "CustomStyleContext", "React", "FormGroup_default", "React", "useContext", "FormLabel_default", "FormLabel", "props", "customStyle", "useContext", "CustomStyleContext", "React", "FormLabel_default", "React", "useContext", "FormInput_default", "FormInput", "props", "customStyle", "useContext", "CustomStyleContext", "onChange", "event", "React", "FormInput_default", "React", "useContext", "FormError_default", "FormError", "props", "customStyle", "useContext", "CustomStyleContext", "React", "FormError_default", "React", "useContext", "FormButtonGroup_default", "FormButtonGroup", "props", "customStyle", "useContext", "CustomStyleContext", "React", "FormButtonGroup_default", "React", "useContext", "FormButton_default", "FormButton", "props", "customStyles", "useContext", "CustomStyleContext", "onMouseDown", "event", "React", "FormButton_default", "Form", "props", "customStyle", "useContext", "CustomStyleContext", "React", "Form_default", "FormGroup", "FormLabel", "FormInput", "FormError", "FormButtonGroup", "FormButton", "HyperlinkToolbarButton", "customStyle", "useContext", "CustomStyleContext", "editor", "useSlate", "showPopover", "setShowPopover", "useState", "href", "setHref", "hrefInputRef", "useRef", "useEffect", "nearestHyperlink", "SlateUtils", "onClosePopover", "ReactEditor", "onClickToolbarButton", "onClickSubmit", "HyperlinkHelper", "isHyperlink", "useMemo", "onClickRemove", "onPressEnter", "React", "HyperlinkToolbarButton_default", "ToolbarButton", "Popover", "Form", "ReactEditor", "useSlate", "React", "useContext", "useEffect", "useRef", "useState", "ImageToolbarButton_default", "ImageToolbarButton", "props", "customStyle", "useContext", "CustomStyleContext", "editor", "useSlate", "showPopover", "setShowPopover", "useState", "src", "setSrc", "srcInputRef", "useRef", "useEffect", "nearestImage", "SlateUtils", "onClosePopover", "ReactEditor", "onClickToolbarButton", "onClickSubmit", "ImageHelper", "onPressEnter", "onClickUpload", "React", "ImageToolbarButton_default", "ToolbarButton", "Popover", "Form", "Toolbar", "props", "editor", "useSlate", "customStyle", "useContext", "CustomStyleContext", "onClickBold", "CustomLeafHelper", "onClickItalic", "onClickHeading", "level", "Helpers", "onClickUnorderedList", "UnorderedListItemHelper", "onClickOrderedList", "OrderedListItemHelper", "onClickBlockquote", "BlockquoteHelper", "onClickCode", "CodeHelper", "onClickUpload", "activeStatus", "Heading1Helper", "Heading2Helper", "Heading3Helper", "Heading4Helper", "Heading5Helper", "Heading6Helper", "UnorderedListHelper", "OrderedListHelper", "HyperlinkHelper", "React", "Toolbar_default", "ToolbarButton", "ToolbarButtonSpacer", "headingLevel", "HyperlinkToolbarButton", "ImageToolbarButton", "MarkdownEditor_default", "elements_default", "React", "useContext", "useEffect", "useState", "UploadModal_default", "React", "useContext", "useRef", "IoCloseOutline", "Modal_default", "useOnClickOutside", "Modal", "props", "customStyle", "useContext", "CustomStyleContext", "clickOutsideRef", "useRef", "useOnClickOutside", "React", "Modal_default", "IoCloseOutline", "UploadModal", "props", "customStyle", "useContext", "CustomStyleContext", "errorMessage", "setErrorMessage", "useState", "uploadProgress", "setUploadProgress", "onUploadError", "error", "onUploadProgress", "progress", "onUploadFinish", "url", "originalFile", "metaData", "useEffect", "onFileSelect", "event", "files", "selectedFiles", "file", "fileTypeMatches", "selectedFile", "React", "Modal", "Form", "FormGroup", "UploadModal_default", "fileType", "expectedFileTypes", "expectedFileType", "mainType", "React", "ImageElement", "props", "React", "HyperlinkElement", "props", "React", "CustomStyleContextProvider", "props", "React", "CustomStyleContext", "React", "OrderedListItemElement", "props", "MarkdownEditor", "props", "editor", "useState", "withVoids", "withInlines", "withReact", "createEditor", "uploadModalData", "setUploadModalData", "currentAst", "useRef", "renderElement", "useCallback", "React", "BlockquoteElement", "CodeElement", "Heading1Element", "Heading2Element", "Heading3Element", "Heading4Element", "Heading5Element", "Heading6Element", "ImageElement", "HyperlinkElement", "OrderedListItemElement", "OrderedListElement", "UnorderedListElement", "UnorderedListItemElement", "ParagraphElement", "renderLeaf", "CustomLeaf", "onKeyDown", "event", "CustomLeafHelper", "shortcutText", "SlateUtils", "blockRendered", "helper", "BlockHelpersArray", "InlineHelpersArray", "match", "currentBlockType", "onTabFunc", "Helpers", "currentElementType", "onEnterFunc", "onSlateChange", "value", "op", "onBlur", "onUploadRequest", "accept", "forceAttachment", "onCloseUploadModal", "ReactEditor", "onUploadFinished", "fileUrl", "originalFile", "metaData", "ImageHelper", "HyperlinkHelper", "initialValue", "useMemo", "CustomStyleContextProvider", "Slate", "MarkdownEditor_default", "Toolbar", "Editable", "elements_default", "UploadModal", "isInline", "element", "isVoid", "VoidHelpersArray", "React", "useMemo", "elementTypesCount", "elementTypes", "targetType", "elementType", "getIndentsText", "num", "serializers", "value", "parents", "serializeChildren", "listsCount", "result", "serializeLeaf", "text", "serializeElement", "func", "serializeElementOrLeaf", "element", "SlateUtils", "customElement", "children", "joinValue", "child", "toMarkdown", "editorValue", "ReactMarkdown", "remarkGfm", "remarkBreaks", "MarkdownView", "props", "markdown", "useMemo", "toMarkdown", "React", "elements_default", "ReactMarkdown", "remarkGfm", "remarkBreaks", "AbstractUploader", "progress", "url", "originalFile", "metaData", "error", "callback"]
}
